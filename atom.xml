<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[xixitalk's snippet]]></title>
  <link href="http://xixitalk.github.io/atom.xml" rel="self"/>
  <link href="http://xixitalk.github.io/"/>
  <updated>2016-08-03T03:25:34+00:00</updated>
  <id>http://xixitalk.github.io/</id>
  <author>
    <name><![CDATA[xixitalk]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[fwrite()多了个了0x0D字符]]></title>
    <link href="http://xixitalk.github.io/blog/2016/08/02/fwrite-0x0D/"/>
    <updated>2016-08-02T08:18:55+00:00</updated>
    <id>http://xixitalk.github.io/blog/2016/08/02/fwrite-0x0D</id>
    <content type="html"><![CDATA[<p>fwrite()写文件竟然多了个了0x0D字符，buffer里检查了也确实没有0x0D，一搜索竟然是如果fopen不是二进制打开，fwrite()遇到0x0A额外写一个0x0D。0D 0A是windows平台的换行符，很明显这是只有在windows平台才有的奇特现象。</p>

<!--more-->

<p>解决办法是fopen的flag加个<code>b</code>。</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class=""><span class="line">fopen("sample.bin", "w+");
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>修改成：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class=""><span class="line">fopen("sample.bin", "wb+");
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>另外想起来几年前我遇到过，也解决过，但是忘记了。这次随手记录下来。</p>

<h4 id="section">参考文章</h4>

<p><a href="http://blog.csdn.net/njuitjf/article/details/5821716">http://blog.csdn.net/njuitjf/article/details/5821716</a><br />
<a href="http://stackoverflow.com/questions/5537066/strange-0x0d-being-added-to-my-binary-file">http://stackoverflow.com/questions/5537066/strange-0x0d-being-added-to-my-binary-file</a></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[pthread和errno]]></title>
    <link href="http://xixitalk.github.io/blog/2016/08/01/pthread-errno/"/>
    <updated>2016-08-01T19:10:02+00:00</updated>
    <id>http://xixitalk.github.io/blog/2016/08/01/pthread-errno</id>
    <content type="html"><![CDATA[<p>pthread和errno：pthread函数在出错的时候不会设置errno，而是直接返回错误值。</p>

<!--more-->

<blockquote>
  <p><strong>pthread_create() won’t ever set errno</strong>.  pthread function returns zero
on success, and an error code on error.  So the value you are seeing
in errno is either the result of an error in some previous other
system call, or errno is just starting out at EINTR and never getting
changed (this has happened to me).</p>
</blockquote>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
</pre></td><td class="code"><pre><code class=""><span class="line"> #define handle_error_en(en, msg) \
</span><span class="line">               do { errno = en; perror(msg); exit(EXIT_FAILURE); } while (0)
</span><span class="line">
</span><span class="line">s = pthread_create(&amp;tinfo[tnum].thread_id, &amp;attr,
</span><span class="line">                      &amp;thread_start, &amp;tinfo[tnum]);
</span><span class="line">if (s != 0)
</span><span class="line">    handle_error_en(s, "pthread_create");
</span></code></pre></td></tr></table></div></figure></notextile></div>

<h4 id="section">参考资料</h4>

<p><a href="http://man7.org/linux/man-pages/man3/pthread_create.3.html">http://man7.org/linux/man-pages/man3/pthread_create.3.html</a><br />
<a href="https://sourceware.org/ml/libc-alpha/2000-10/msg00153.html">https://sourceware.org/ml/libc-alpha/2000-10/msg00153.html</a><br />
<a href="http://www.oschina.net/question/234345_40365">http://www.oschina.net/question/234345_40365</a></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[C库线程安全函数]]></title>
    <link href="http://xixitalk.github.io/blog/2016/07/31/Thread-safe-C-library-functions/"/>
    <updated>2016-07-31T08:28:21+00:00</updated>
    <id>http://xixitalk.github.io/blog/2016/07/31/Thread-safe-C-library-functions</id>
    <content type="html"><![CDATA[<p>C库线程安全函数和不安全函数</p>

<!--more-->

<p><a href="http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.dui0492c/Chdiedfe.html">http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.dui0492c/Chdiedfe.html</a></p>

<p>线程安全函数</p>

<table>
  <thead>
    <tr>
      <th>Functions</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>calloc(),free(),malloc(),realloc()</td>
      <td>The heap functions are thread-safe if the <em>mutex</em>* functions are implemented.A single heap is shared between all threads, and mutexes are used to avoid data corruption when there is concurrent access. Each heap implementation is responsible for doing its own locking. If you supply your own allocator, it must also do its own locking. This enables it to do fine-grained locking if required, rather than protecting the entire heap with a single mutex (coarse-grained locking).</td>
    </tr>
    <tr>
      <td>alloca()</td>
      <td>alloca() is thread-safe because it allocates memory on the stack.</td>
    </tr>
    <tr>
      <td>abort(),raise(),signal(),fenv.h</td>
      <td>The ARM signal handling functions and floating-point exception traps are thread-safe.The settings for signal handlers and floating-point traps are global across the entire process and are protected by locks. Data corruption does not occur if multiple threads call signal() or an fenv.h function at the same time. However, be aware that the effects of the call act on all threads and not only on the calling thread.</td>
    </tr>
    <tr>
      <td>clearerr(), fclose(),feof(),ferror(), fflush(),fgetc(),fgetpos(), fgets(),fopen(),fputc(), fputs(),fread(),freopen(), fseek(),fsetpos(),ftell(), fwrite(),getc(),getchar(), gets(),perror(),putc(), putchar(),puts(),rewind(), setbuf(),setvbuf(),tmpfile(), tmpnam(),ungetc()</td>
      <td>The stdio library is thread-safe if the <em>mutex</em>* functions are implemented.Each individual stream is protected by a lock, so two threads can each open their own stdio stream and use it, without interfering with one another.If two threads both want to read or write the same stream, locking at the fgetc() and fputc() level prevents data corruption, but it is possible that the individual characters output by each thread might be interleaved in a confusing way. <strong>Note</strong> tmpnam() also contains a static buffer but this is only used if the argument is NULL. To ensure that your use of tmpnam() is thread-safe, supply your own buffer space.</td>
    </tr>
    <tr>
      <td>fprintf(), printf(),vfprintf(), vprintf(), fscanf(),scanf()</td>
      <td>When using these functions:the standard C printf() and scanf() functions use stdio so they are thread-safe. the standard C printf() function is susceptible to changes in the locale settings if called in a multithreaded program.</td>
    </tr>
    <tr>
      <td>clock()</td>
      <td>clock() contains static data that is written once at program startup and then only ever read. Therefore, clock() is thread-safe provided no extra threads are already running at the time that the library is initialized.</td>
    </tr>
    <tr>
      <td>errno</td>
      <td>errno is thread-safe.Each thread has its own errno stored in a __user_perthread_libspace block. This means that each thread can call errno-setting functions independently and then check errno afterwards without interference from other threads.</td>
    </tr>
    <tr>
      <td>atexit()</td>
      <td>The list of exit functions maintained by atexit() is process-global and protected by a lock.In the worst case, if more than one thread calls atexit(), the order that exit functions are called cannot be guaranteed.</td>
    </tr>
    <tr>
      <td>abs(), acos(), asin(),atan(),atan2(), atof(),atol(), atoi(),bsearch(),ceil(), cos(),cosh(),difftime(), div(),exp(),fabs(), floor(),fmod(),frexp(), labs(),ldexp(),ldiv(), log(),log10(),memchr(), memcmp(),memcpy(),memmove(), memset(),mktime(),modf(), pow(),qsort(),sin(), sinh(),sqrt(),strcat(), strchr(),strcmp(),strcpy(), strcspn(),strlcat(),strlcpy(), strlen(),strncat(),strncmp(), strncpy(),strpbrk(),strrchr(), strspn(),strstr(),strxfrm(), tan(), tanh()</td>
      <td>These functions are inherently thread-safe.</td>
    </tr>
    <tr>
      <td>longjmp(), setjmp()</td>
      <td>Although setjmp() and longjmp() keep data in <em>_user_libspace, they call the __alloca</em>* functions, that are thread-safe.</td>
    </tr>
    <tr>
      <td>remove(), rename(), time()</td>
      <td>These functions use interrupts that communicate with the ARM debugging environments. Typically, you have to reimplement these for a real-world application.</td>
    </tr>
    <tr>
      <td>snprintf(), sprintf(),vsnprintf(),vsprintf(), sscanf(),isalnum(),isalpha(), iscntrl(),isdigit(),isgraph(), islower(),isprint(),ispunct(), isspace(),isupper(),isxdigit(), tolower(),toupper(),strcoll(), strtod(),strtol(),strtoul(), strftime()</td>
      <td>When using these functions, the string-based functions read the locale settings. Typically, they are thread-safe. However, if you change locale in mid-session, you must ensure that these functions are not affected.The string-based functions, such as sprintf() and sscanf(), do not depend on the stdio library.</td>
    </tr>
    <tr>
      <td>stdin, stdout, stderr</td>
      <td>These functions are thread-safe.</td>
    </tr>
  </tbody>
</table>

<p>线程不安全函数</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[linux内核代码瘦身]]></title>
    <link href="http://xixitalk.github.io/blog/2016/07/20/linux-kernel-source-strip/"/>
    <updated>2016-07-20T21:07:23+00:00</updated>
    <id>http://xixitalk.github.io/blog/2016/07/20/linux-kernel-source-strip</id>
    <content type="html"><![CDATA[<p>linux内核代码瘦身，原理：把不参与编译的代码删除，这样用Source Insight工具阅读代码的时候就轻简了很多。</p>

<p>例子数据：原本一个嵌入式linux内核代码1万7千个C文件，精简之后只有1222个C文件，删除了1万6千个C文件。</p>

<!--more-->

<h4 id="section">第一步 清理临时文件</h4>

<p>内核编译clean，把内核编译的临时文件都清除。</p>

<h4 id="c">第二步 保存所有C文件路径</h4>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
</pre></td><td class="code"><pre><code class=""><span class="line">cd linux-3.4.5
</span><span class="line">find ./ -name "*.c" | tee allsrc.txt
</span></code></pre></td></tr></table></div></figure></notextile></div>

<h4 id="section-1">第三步 编译内核</h4>

<p>无需多讲，编译内核。</p>

<h4 id="strippy">第四步 用strip.py清除不参与编译的代码</h4>

<p>部分代码使用了include C代码，所以用<code>ignorefilelist</code>自定义文件过滤。<code>scripts</code>是工具目录，<code>./drivers/usb/gadget/</code>里inlucde C代码太多了，所以这两个目录直接目录过滤，添加到<code>ignorepathlist</code>自定义目录过滤里。</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
<span class="line-number">21</span>
<span class="line-number">22</span>
<span class="line-number">23</span>
<span class="line-number">24</span>
<span class="line-number">25</span>
<span class="line-number">26</span>
<span class="line-number">27</span>
<span class="line-number">28</span>
<span class="line-number">29</span>
<span class="line-number">30</span>
<span class="line-number">31</span>
<span class="line-number">32</span>
<span class="line-number">33</span>
<span class="line-number">34</span>
<span class="line-number">35</span>
<span class="line-number">36</span>
<span class="line-number">37</span>
<span class="line-number">38</span>
<span class="line-number">39</span>
<span class="line-number">40</span>
<span class="line-number">41</span>
<span class="line-number">42</span>
<span class="line-number">43</span>
<span class="line-number">44</span>
<span class="line-number">45</span>
</pre></td><td class="code"><pre><code class=""><span class="line">import sys
</span><span class="line">import os
</span><span class="line">
</span><span class="line">ignorefilelist=['fsr-2level.c','fsr-3level.c','percpu-km.c','percpu-vm.c','nf_conntrack_h323_types.c']
</span><span class="line">ignorepathlist=['./scripts/','./drivers/usb/gadget/']
</span><span class="line">
</span><span class="line">f = open('allsrc.txt','r')  
</span><span class="line">
</span><span class="line">for line in f.readlines():
</span><span class="line">	cfilename=line.strip('\n')
</span><span class="line">	objfilename=cfilename.replace(".c",".o")
</span><span class="line">	asmfilename=cfilename.replace(".c",".s")
</span><span class="line">	exefilename=cfilename.replace(".c","")
</span><span class="line">
</span><span class="line">	cfile=cfilename.split('/')[-1]
</span><span class="line">	#print cfile
</span><span class="line">	
</span><span class="line">	flag=False
</span><span class="line">	for item in ignorepathlist:
</span><span class="line">		if cfilename.find(item)!=-1:
</span><span class="line">			#print cfilename
</span><span class="line">			flag=True
</span><span class="line">			break
</span><span class="line">	if flag:
</span><span class="line">		continue
</span><span class="line">	
</span><span class="line">	if cfile in ignorefilelist:
</span><span class="line">		#print cfile,cfilename
</span><span class="line">		continue
</span><span class="line">	
</span><span class="line">	if  os.path.exists(objfilename):
</span><span class="line">		continue
</span><span class="line">	if os.path.exists(asmfilename):
</span><span class="line">		#print asmfilename
</span><span class="line">		continue
</span><span class="line">	if os.path.exists(exefilename):
</span><span class="line">		#print exefilename
</span><span class="line">		continue
</span><span class="line">	
</span><span class="line">	if os.path.exists(cfilename):
</span><span class="line">		print objfilename,"NOT USING and rm ",cfilename
</span><span class="line">		os.remove(cfilename)
</span><span class="line">		pass
</span><span class="line">
</span><span class="line">f.close()
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>保存代码为<code>strip.py</code>，保存在内核目录。</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
</pre></td><td class="code"><pre><code class=""><span class="line">cd linux-3.4.5
</span><span class="line">python strip.py
</span></code></pre></td></tr></table></div></figure></notextile></div>

<h3 id="section-2">第五步 重新编译内核</h3>

<p>重新编译内核。</p>

<p>如果编译成功，清理临时文件后保存代码用于阅读；<br />
如果编译失败，恢复缺失的文件，修改strip.py，接着编译，直到内核重新编译通过，清理临时文件后保存代码用于阅读。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[linux内核代码预处理后便于阅读]]></title>
    <link href="http://xixitalk.github.io/blog/2016/07/19/preprocess-linux-kernel/"/>
    <updated>2016-07-19T13:39:01+00:00</updated>
    <id>http://xixitalk.github.io/blog/2016/07/19/preprocess-linux-kernel</id>
    <content type="html"><![CDATA[<p>linux 内核庞大而复杂。内核代码阅读的时候，有没有遇到因为宏定义或者inline层次太深而不知道到底代码是什么样子。代码预处理可以解决这个难题。</p>

<!--more-->

<p>平台：linux 3.4.5 ARM，PC linux上类似，更简单些。</p>

<h4 id="v1">加V=1重新编译内核</h4>

<p><code>make</code>内核增加<code>V=1</code>选项，会详细打印编译过程，<code>-B</code>是要求重新编译内核所有模块。</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class=""><span class="line">cd linux-3.4.5 &amp;&amp; make ARCH=arm defconfig &amp;&amp; make ARCH=arm CROSS_COMPILE=arm-buildroot-linux-uclibcgnueabi- EXTRAVERSION=- -B V=1 uImage
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>编译内核并保存编译log到文件，搜索你要预编译的文件，如<code>mm/slab.c</code>，会找到如下编译命令：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class=""><span class="line">arm-buildroot-linux-uclibcgnueabi-gcc -Wp,-MD,mm/.slab.o.d  -nostdinc -isystem /home/test/build/gcc-4.9.8/build_arm/staging_dir/usr/bin/../lib/gcc/arm-buildroot-linux-uclibcgnueabi/4.9.8/include -I/home/test/linux/kernels/linux-3.4.5/arch/arm/include -Iarch/arm/include/generated -Iinclude  -include /home/test/linux/kernels/linux-3.4.5/include/linux/kconfig.h -D__KERNEL__ -mlittle-endian -Iarch/arm/mach-zx297510/include -Wall -Wundef -Wstrict-prototypes -Wno-trigraphs -fno-strict-aliasing -fno-common -Werror-implicit-function-declaration -Wno-format-security -fno-delete-null-pointer-checks -O2 -marm -fno-dwarf2-cfi-asm -mabi=aapcs-linux -mno-thumb-interwork -funwind-tables -D__LINUX_ARM_ARCH__=7 -march=armv7-a -msoft-float -Uarm -Wframe-larger-than=1024 -fno-stack-protector -Wno-unused-but-set-variable -fomit-frame-pointer -g -fno-inline-functions-called-once -Wdeclaration-after-statement -Wno-pointer-sign -fno-strict-overflow -fconserve-stack -DCC_HAVE_ASM_GOTO    -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(slab)"  -D"KBUILD_MODNAME=KBUILD_STR(slab)" -c -o mm/.tmp_slab.o mm/slab.c
</span></code></pre></td></tr></table></div></figure></notextile></div>

<h4 id="section">编译预处理指定文件</h4>

<p>把编译命令修改成预处理命令：<code>-c -o mm/.tmp_slab.o</code>修改成<code>-E -o mm/slab.E mm/slab.c</code>，在内核目录<code>linux-3.4.5</code>直接执行。如果是交叉编译链，可能需要把<code>arm-buildroot-linux-uclibcgnueabi-gcc</code>所在路径加入到环境变量<code>PATH</code>里。</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class=""><span class="line">arm-buildroot-linux-uclibcgnueabi-gcc -Wp,-MD,mm/.slab.o.d  -nostdinc -isystem /home/test/build/gcc-4.9.8/build_arm/staging_dir/usr/bin/../lib/gcc/arm-buildroot-linux-uclibcgnueabi/4.9.8/include -I/home/test/linux/kernels/linux-3.4.5/arch/arm/include -Iarch/arm/include/generated -Iinclude  -include /home/test/linux/kernels/linux-3.4.5/include/linux/kconfig.h -D__KERNEL__ -mlittle-endian -Iarch/arm/mach-zx297510/include -Wall -Wundef -Wstrict-prototypes -Wno-trigraphs -fno-strict-aliasing -fno-common -Werror-implicit-function-declaration -Wno-format-security -fno-delete-null-pointer-checks -O2 -marm -fno-dwarf2-cfi-asm -mabi=aapcs-linux -mno-thumb-interwork -funwind-tables -D__LINUX_ARM_ARCH__=7 -march=armv7-a -msoft-float -Uarm -Wframe-larger-than=1024 -fno-stack-protector -Wno-unused-but-set-variable -fomit-frame-pointer -g -fno-inline-functions-called-once -Wdeclaration-after-statement -Wno-pointer-sign -fno-strict-overflow -fconserve-stack -DCC_HAVE_ASM_GOTO    -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(slab)"  -D"KBUILD_MODNAME=KBUILD_STR(slab)" -E -o mm/slab.E mm/slab.c
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>执行完命令，在内核的<code>mm</code>目录就能看到<code>slab.c</code>的预处理后文件<code>slab.E</code>文件了。看一下<code>kmalloc</code>函数代码，是不是清晰很多了。</p>

<p><code>slab_def.h</code>里的原始<code>kmalloc</code></p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
<span class="line-number">21</span>
<span class="line-number">22</span>
<span class="line-number">23</span>
<span class="line-number">24</span>
<span class="line-number">25</span>
<span class="line-number">26</span>
<span class="line-number">27</span>
<span class="line-number">28</span>
<span class="line-number">29</span>
<span class="line-number">30</span>
<span class="line-number">31</span>
<span class="line-number">32</span>
<span class="line-number">33</span>
</pre></td><td class="code"><pre><code class=""><span class="line">static __always_inline void *kmalloc(size_t size, gfp_t flags)
</span><span class="line">{
</span><span class="line">	struct kmem_cache *cachep;
</span><span class="line">	void *ret;
</span><span class="line">
</span><span class="line">	if (__builtin_constant_p(size)) {
</span><span class="line">		int i = 0;
</span><span class="line">
</span><span class="line">		if (!size)
</span><span class="line">			return ZERO_SIZE_PTR;
</span><span class="line">
</span><span class="line">#define CACHE(x) \
</span><span class="line">		if (size &lt;= x) \
</span><span class="line">			goto found; \
</span><span class="line">		else \
</span><span class="line">			i++;
</span><span class="line">#include &lt;linux/kmalloc_sizes.h&gt;
</span><span class="line">#undef CACHE
</span><span class="line">		return NULL;
</span><span class="line">found:
</span><span class="line">#ifdef CONFIG_ZONE_DMA
</span><span class="line">		if (flags &amp; GFP_DMA)
</span><span class="line">			cachep = malloc_sizes[i].cs_dmacachep;
</span><span class="line">		else
</span><span class="line">#endif
</span><span class="line">			cachep = malloc_sizes[i].cs_cachep;
</span><span class="line">
</span><span class="line">		ret = kmem_cache_alloc_trace(size, cachep, flags);
</span><span class="line">
</span><span class="line">		return ret;
</span><span class="line">	}
</span><span class="line">	return __kmalloc(size, flags);
</span><span class="line">}
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>预处理后的<code>kmalloc</code>,流程是不是清晰多了。</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
<span class="line-number">21</span>
<span class="line-number">22</span>
<span class="line-number">23</span>
<span class="line-number">24</span>
<span class="line-number">25</span>
<span class="line-number">26</span>
<span class="line-number">27</span>
<span class="line-number">28</span>
<span class="line-number">29</span>
<span class="line-number">30</span>
<span class="line-number">31</span>
<span class="line-number">32</span>
<span class="line-number">33</span>
<span class="line-number">34</span>
<span class="line-number">35</span>
<span class="line-number">36</span>
<span class="line-number">37</span>
<span class="line-number">38</span>
<span class="line-number">39</span>
<span class="line-number">40</span>
<span class="line-number">41</span>
<span class="line-number">42</span>
<span class="line-number">43</span>
<span class="line-number">44</span>
</pre></td><td class="code"><pre><code class=""><span class="line">static inline __attribute__((always_inline)) __attribute__((always_inline)) void *kmalloc(size_t size, gfp_t flags)
</span><span class="line">{
</span><span class="line"> struct kmem_cache *cachep;
</span><span class="line"> void *ret;
</span><span class="line">
</span><span class="line"> if (__builtin_constant_p(size)) {
</span><span class="line">  int i = 0;
</span><span class="line">
</span><span class="line">  if (!size)
</span><span class="line">   return ((void *)16);
</span><span class="line">
</span><span class="line"># 1 "include/linux/kmalloc_sizes.h" 1
</span><span class="line">
</span><span class="line"> if (size &lt;= 32) goto found; else i++;
</span><span class="line"> if (size &lt;= 64) goto found; else i++;
</span><span class="line"> if (size &lt;= 128) goto found; else i++;
</span><span class="line"> if (size &lt;= 192) goto found; else i++;
</span><span class="line"> if (size &lt;= 256) goto found; else i++;
</span><span class="line"> if (size &lt;= 512) goto found; else i++;
</span><span class="line"> if (size &lt;= 1024) goto found; else i++;
</span><span class="line"> if (size &lt;= 2048) goto found; else i++;
</span><span class="line"> if (size &lt;= 4096) goto found; else i++;
</span><span class="line"> if (size &lt;= 8192) goto found; else i++;
</span><span class="line"> if (size &lt;= 16384) goto found; else i++;
</span><span class="line"> if (size &lt;= 32768) goto found; else i++;
</span><span class="line"> if (size &lt;= 65536) goto found; else i++;
</span><span class="line"> if (size &lt;= 131072) goto found; else i++;
</span><span class="line"> if (size &lt;= 262144) goto found; else i++;
</span><span class="line"> if (size &lt;= 524288) goto found; else i++;
</span><span class="line"> if (size &lt;= 1048576) goto found; else i++;
</span><span class="line"> if (size &lt;= 2097152) goto found; else i++;
</span><span class="line"> if (size &lt;= 4194304) goto found; else i++;
</span><span class="line"># 145 "include/linux/slab_def.h" 2
</span><span class="line">
</span><span class="line">  return ((void *)0);
</span><span class="line">found:
</span><span class="line">   cachep = malloc_sizes[i].cs_cachep;
</span><span class="line">
</span><span class="line">  ret = kmem_cache_alloc_trace(size, cachep, flags);
</span><span class="line">
</span><span class="line">  return ret;
</span><span class="line"> }
</span><span class="line"> return __kmalloc(size, flags);
</span><span class="line">}
</span></code></pre></td></tr></table></div></figure></notextile></div>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[linux栈和内存管理]]></title>
    <link href="http://xixitalk.github.io/blog/2016/07/18/linux-stack-and-memory-management/"/>
    <updated>2016-07-18T09:11:52+00:00</updated>
    <id>http://xixitalk.github.io/blog/2016/07/18/linux-stack-and-memory-management</id>
    <content type="html"><![CDATA[<p>先记录，待细看</p>

<!--more-->

<p><a href="http://blog.csdn.net/daniel_ice/article/details/8146003">http://blog.csdn.net/daniel_ice/article/details/8146003</a></p>

<p><a href="http://gityuan.com/2015/10/30/kernel-memory/">http://gityuan.com/2015/10/30/kernel-memory/</a></p>

<p><a href="http://www.2ndmoon.net/weblog/?p=509">http://www.2ndmoon.net/weblog/?p=509</a></p>

<p><a href="http://www.cnblogs.com/tolimit/p/4610974.html">http://www.cnblogs.com/tolimit/p/4610974.html</a></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[pthread退出时自动回收资源]]></title>
    <link href="http://xixitalk.github.io/blog/2016/07/18/pthread-autoclean-when-exiting/"/>
    <updated>2016-07-18T08:49:16+00:00</updated>
    <id>http://xixitalk.github.io/blog/2016/07/18/pthread-autoclean-when-exiting</id>
    <content type="html"><![CDATA[<p>pthread线程创建后默认属性是joinable，线程函数执行完资源不会自动回收线程资源，需要主进程<code>pthread_join</code>进行回收，否则就会造成不必要的内存占用，频繁创建退出线程可能会造成系统内存耗尽。除了<code>pthread_join</code>用这种办法更好些。</p>

<!--more-->

<p>线程函数加上<code>pthread_detach(pthread_self())</code>的话，线程状态改变成<code>unjoinable</code>，这样线程函数尾部直接 pthread_exit线程就会自动退出。</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
</pre></td><td class="code"><pre><code class=""><span class="line">static void  thread_fn( void *args)
</span><span class="line">{
</span><span class="line">	pthread_detach(pthread_self());
</span><span class="line">
</span><span class="line">	while(flag)
</span><span class="line">	{
</span><span class="line">		/*do something*/
</span><span class="line">	}
</span><span class="line">
</span><span class="line">	pthread_exit(NULL);
</span><span class="line">}
</span></code></pre></td></tr></table></div></figure></notextile></div>

<h2 id="section">参考文章</h2>

<p><a href="http://blog.csdn.net/trinea/article/details/5191165">http://blog.csdn.net/trinea/article/details/5191165</a></p>

<p><a href="http://www.lxway.net/499814656.html">http://www.lxway.net/499814656.html</a></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[linux内核kmalloc和vmalloc的区别]]></title>
    <link href="http://xixitalk.github.io/blog/2016/07/18/kmalloc-vs-vmalloc/"/>
    <updated>2016-07-18T08:41:56+00:00</updated>
    <id>http://xixitalk.github.io/blog/2016/07/18/kmalloc-vs-vmalloc</id>
    <content type="html"><![CDATA[<p>kmalloc 和 vmalloc的区别</p>

<!--more-->

<h4 id="kmalloc">kmalloc</h4>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class=""><span class="line">void *kmalloc(size_t size, gfp_t flags)
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>kmalloc是内核中最常用的一种内存分配方式，<strong>连续的物理内存</strong>。如果size是常量，调用<code>kmem_cache_alloc_trace</code>分配，否则调用<code>__kmalloc</code>分配。size如果是常量且大于4M，直接返回0（内核版本3.4.5）；如果size是0，返回地址是<code>((void *)16)</code>。</p>

<h4 id="vmalloc">vmalloc</h4>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class=""><span class="line">void *vmalloc(unsigned long size)
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>kmalloc内存分配方式都是物理连续的，能保证较低的平均访问时间。但是在某些场合中，对内存区的请求不是很频繁，较高的内存访问时间也 可以接受，这是就可以分配一段<strong>线性连续，物理不连续</strong>的地址，带来的好处是一次可以分配较大块的内存。vmalloc对 一次能分配的内存大小没有明确限制。</p>

<h5 id="kmalloc-1">kmalloc预处理后的代码</h5>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
<span class="line-number">21</span>
<span class="line-number">22</span>
<span class="line-number">23</span>
<span class="line-number">24</span>
<span class="line-number">25</span>
<span class="line-number">26</span>
<span class="line-number">27</span>
<span class="line-number">28</span>
<span class="line-number">29</span>
<span class="line-number">30</span>
<span class="line-number">31</span>
<span class="line-number">32</span>
<span class="line-number">33</span>
<span class="line-number">34</span>
<span class="line-number">35</span>
<span class="line-number">36</span>
<span class="line-number">37</span>
<span class="line-number">38</span>
<span class="line-number">39</span>
<span class="line-number">40</span>
<span class="line-number">41</span>
<span class="line-number">42</span>
<span class="line-number">43</span>
<span class="line-number">44</span>
<span class="line-number">45</span>
<span class="line-number">46</span>
<span class="line-number">47</span>
<span class="line-number">48</span>
<span class="line-number">49</span>
<span class="line-number">50</span>
<span class="line-number">51</span>
<span class="line-number">52</span>
<span class="line-number">53</span>
<span class="line-number">54</span>
<span class="line-number">55</span>
<span class="line-number">56</span>
<span class="line-number">57</span>
<span class="line-number">58</span>
<span class="line-number">59</span>
<span class="line-number">60</span>
<span class="line-number">61</span>
<span class="line-number">62</span>
<span class="line-number">63</span>
<span class="line-number">64</span>
</pre></td><td class="code"><pre><code class=""><span class="line">static inline __attribute__((always_inline)) __attribute__((always_inline)) void *kmalloc(size_t size, gfp_t flags)
</span><span class="line">{
</span><span class="line"> struct kmem_cache *cachep;
</span><span class="line"> void *ret;
</span><span class="line">
</span><span class="line"> if (__builtin_constant_p(size)) {
</span><span class="line">  int i = 0;
</span><span class="line">
</span><span class="line">  if (!size)
</span><span class="line">   return ((void *)16);
</span><span class="line">
</span><span class="line"># 1 "include/linux/kmalloc_sizes.h" 1
</span><span class="line"> if (size &lt;= 32) goto found; else i++;
</span><span class="line"> if (size &lt;= 64) goto found; else i++;
</span><span class="line"> if (size &lt;= 128) goto found; else i++;
</span><span class="line"> if (size &lt;= 192) goto found; else i++;
</span><span class="line"> if (size &lt;= 256) goto found; else i++;
</span><span class="line"> if (size &lt;= 512) goto found; else i++;
</span><span class="line"> if (size &lt;= 1024) goto found; else i++;
</span><span class="line"> if (size &lt;= 2048) goto found; else i++;
</span><span class="line"> if (size &lt;= 4096) goto found; else i++;
</span><span class="line"> if (size &lt;= 8192) goto found; else i++;
</span><span class="line"> if (size &lt;= 16384) goto found; else i++;
</span><span class="line"> if (size &lt;= 32768) goto found; else i++;
</span><span class="line"> if (size &lt;= 65536) goto found; else i++;
</span><span class="line"> if (size &lt;= 131072) goto found; else i++;
</span><span class="line"> if (size &lt;= 262144) goto found; else i++;
</span><span class="line"> if (size &lt;= 524288) goto found; else i++;
</span><span class="line"> if (size &lt;= 1048576) goto found; else i++;
</span><span class="line"> if (size &lt;= 2097152) goto found; else i++;
</span><span class="line"> if (size &lt;= 4194304) goto found; else i++;
</span><span class="line"># 145 "include/linux/slab_def.h" 2
</span><span class="line">
</span><span class="line">  return ((void *)0);
</span><span class="line">found:
</span><span class="line">   cachep = malloc_sizes[i].cs_cachep;
</span><span class="line">
</span><span class="line">  ret = kmem_cache_alloc_trace(size, cachep, flags);
</span><span class="line">
</span><span class="line">  return ret;
</span><span class="line"> }
</span><span class="line"> return __kmalloc(size, flags);
</span><span class="line">}
</span><span class="line">
</span><span class="line">void *__kmalloc(size_t size, gfp_t flags)
</span><span class="line">{
</span><span class="line"> return __do_kmalloc(size, flags, ((void *)0));
</span><span class="line">}
</span><span class="line">
</span><span class="line">static inline __attribute__((always_inline)) __attribute__((always_inline)) void *__do_kmalloc(size_t size, gfp_t flags, void *caller)
</span><span class="line">{
</span><span class="line"> struct kmem_cache *cachep;
</span><span class="line"> void *ret;
</span><span class="line"> 
</span><span class="line"> cachep = __find_general_cachep(size, flags);
</span><span class="line"> if (__builtin_expect(!!(((unsigned long)(cachep) &lt;= (unsigned long)((void *)16))), 0))
</span><span class="line">  return cachep;
</span><span class="line"> ret = __cache_alloc(cachep, flags, caller);
</span><span class="line">
</span><span class="line"> trace_kmalloc((unsigned long) caller, ret,
</span><span class="line">        size, cachep-&gt;buffer_size, flags);
</span><span class="line">
</span><span class="line"> return ret;
</span><span class="line">}
</span></code></pre></td></tr></table></div></figure></notextile></div>

<h1 id="section">引用文章</h1>

<p><a href="http://www.ahlinux.com/start/kernel/18604.html">http://www.ahlinux.com/start/kernel/18604.html</a></p>

<p><a href="http://blog.csdn.net/bullbat/article/details/7181396">http://blog.csdn.net/bullbat/article/details/7181396</a></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[linux kernel全局变量contig_page_data含义]]></title>
    <link href="http://xixitalk.github.io/blog/2016/07/13/kernel-contig_page_data/"/>
    <updated>2016-07-13T09:03:20+00:00</updated>
    <id>http://xixitalk.github.io/blog/2016/07/13/kernel-contig_page_data</id>
    <content type="html"><![CDATA[<p><code>contig_page_data</code>是内核内存管理一个很重要的变量。</p>

<!--more-->

<p>平台：uClinux 内核版本号：linux-3.4.12</p>

<p><img src="http://7bv9id.com1.z0.glb.clouddn.com/contig_page_data.png" alt="enter image description here" /></p>

<p><code>watermark</code>是3840 4800 5760对应 watermark[min] watermark[low] watermark[high]，这里是page数，一个page 4K，所以<code>watermark</code>对应<code>min_free_kbytes</code>是3840*4K是15360（15M），符合配置<code>echo 15360 &gt; /proc/sys/vm/min_free_kbytes</code>。其他计算如下。</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
</pre></td><td class="code"><pre><code class=""><span class="line"> watermark[min] = min_free_kbytes换算为page单位即可
</span><span class="line"> watermark[low] = watermark[min] * 5 / 4
</span><span class="line"> watermark[high] = watermark[min] * 3 / 2
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>在系统空闲内存低于 watermark[low]时，开始启动内核线程kswapd进行内存回收，直到该zone的空闲内存数量达到watermark[high]后停止回收。如果上层申请内存的速度太快，导致空闲内存降至watermark[min]后，内核就会进行direct reclaim（直接回收），即直接在应用程序的进程上下文中进行回收，再用回收上来的空闲页满足内存申请，因此实际会阻塞应用程序，带来一定的响应延迟，而且可能会触发系统OOM。这是因为watermark[min]以下的内存属于系统的自留内存，用以满足特殊使用，所以不会给用户态的普通申请来用。</p>

<p>free_area里order是0到10，对应4K到4M。free_list[n]是双向链表，只有next的next指向同样的节点才是表示链表为空。（双向链表，很明显如果只有两个节点，next和prev都是另一个节点）。和<code>cat /proc/pagetypeinfo</code>信息一致。</p>

<p><code>contig_page_data</code>里的<code>vm_stat</code>对应mmzone.h里<code>zone_stat_item</code>枚举。另外本身有一个内核全局变量<code>vm_stat</code>，值和<code>contig_page_data</code>的这个<code>vm_stat</code>一样的。这个参数可以对照着<code>/proc/meminfo</code>一起看。</p>

<p>page_alloc.c  show_free_areas()</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
</pre></td><td class="code"><pre><code class=""><span class="line">for (type = 0; type &lt; MIGRATE_TYPES; type++) {
</span><span class="line">				if (!list_empty(&amp;area-&gt;free_list[type]))
</span><span class="line">					types[order] |= 1 &lt;&lt; type;
</span><span class="line">			}
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>mmzone.h里看出MIGRATE_TYPES为4。<strong>0是UNMOVABLE区，1是RECLAIMABLE可回收区，2是可MOVABLE区，3是PCPTYPES或者RESERVE保留区</strong>。</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
<span class="line-number">21</span>
<span class="line-number">22</span>
<span class="line-number">23</span>
<span class="line-number">24</span>
<span class="line-number">25</span>
<span class="line-number">26</span>
<span class="line-number">27</span>
</pre></td><td class="code"><pre><code class=""><span class="line">enum {
</span><span class="line">	MIGRATE_UNMOVABLE,
</span><span class="line">	MIGRATE_RECLAIMABLE,
</span><span class="line">	MIGRATE_MOVABLE,
</span><span class="line">	MIGRATE_PCPTYPES,	/* the number of types on the pcp lists */
</span><span class="line">	MIGRATE_RESERVE = MIGRATE_PCPTYPES,
</span><span class="line">#ifdef CONFIG_CMA
</span><span class="line">	/*
</span><span class="line">	 * MIGRATE_CMA migration type is designed to mimic the way
</span><span class="line">	 * ZONE_MOVABLE works.  Only movable pages can be allocated
</span><span class="line">	 * from MIGRATE_CMA pageblocks and page allocator never
</span><span class="line">	 * implicitly change migration type of MIGRATE_CMA pageblock.
</span><span class="line">	 *
</span><span class="line">	 * The way to use it is to change migratetype of a range of
</span><span class="line">	 * pageblocks to MIGRATE_CMA which can be done by
</span><span class="line">	 * __free_pageblock_cma() function.  What is important though
</span><span class="line">	 * is that a range of pageblocks must be aligned to
</span><span class="line">	 * MAX_ORDER_NR_PAGES should biggest page be bigger then
</span><span class="line">	 * a single pageblock.
</span><span class="line">	 */
</span><span class="line">	MIGRATE_CMA,
</span><span class="line">#endif
</span><span class="line">#ifdef CONFIG_MEMORY_ISOLATION
</span><span class="line">	MIGRATE_ISOLATE,	/* can't allocate from here */
</span><span class="line">#endif
</span><span class="line">	MIGRATE_TYPES
</span><span class="line">};
</span></code></pre></td></tr></table></div></figure></notextile></div>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
<span class="line-number">21</span>
<span class="line-number">22</span>
<span class="line-number">23</span>
<span class="line-number">24</span>
<span class="line-number">25</span>
<span class="line-number">26</span>
<span class="line-number">27</span>
<span class="line-number">28</span>
<span class="line-number">29</span>
<span class="line-number">30</span>
<span class="line-number">31</span>
<span class="line-number">32</span>
<span class="line-number">33</span>
<span class="line-number">34</span>
<span class="line-number">35</span>
<span class="line-number">36</span>
<span class="line-number">37</span>
<span class="line-number">38</span>
<span class="line-number">39</span>
<span class="line-number">40</span>
<span class="line-number">41</span>
<span class="line-number">42</span>
<span class="line-number">43</span>
</pre></td><td class="code"><pre><code class=""><span class="line">enum zone_stat_item {
</span><span class="line">	/* First 128 byte cacheline (assuming 64 bit words) */
</span><span class="line">	NR_FREE_PAGES,
</span><span class="line">	NR_ALLOC_BATCH,
</span><span class="line">	NR_LRU_BASE,
</span><span class="line">	NR_INACTIVE_ANON = NR_LRU_BASE, /* must match order of LRU_[IN]ACTIVE */
</span><span class="line">	NR_ACTIVE_ANON,		/*  "     "     "   "       "         */
</span><span class="line">	NR_INACTIVE_FILE,	/*  "     "     "   "       "         */
</span><span class="line">	NR_ACTIVE_FILE,		/*  "     "     "   "       "         */
</span><span class="line">	NR_UNEVICTABLE,		/*  "     "     "   "       "         */
</span><span class="line">	NR_MLOCK,		/* mlock()ed pages found and moved off LRU */
</span><span class="line">	NR_ANON_PAGES,	/* Mapped anonymous pages */
</span><span class="line">	NR_FILE_MAPPED,	/* pagecache pages mapped into pagetables.
</span><span class="line">			   only modified from process context */
</span><span class="line">	NR_FILE_PAGES,
</span><span class="line">	NR_FILE_DIRTY,
</span><span class="line">	NR_WRITEBACK,
</span><span class="line">	NR_SLAB_RECLAIMABLE,
</span><span class="line">	NR_SLAB_UNRECLAIMABLE,
</span><span class="line">	NR_PAGETABLE,		/* used for pagetables */
</span><span class="line">	NR_KERNEL_STACK,
</span><span class="line">	/* Second 128 byte cacheline */
</span><span class="line">	NR_UNSTABLE_NFS,	/* NFS unstable pages */
</span><span class="line">	NR_BOUNCE,
</span><span class="line">	NR_VMSCAN_WRITE,
</span><span class="line">	NR_VMSCAN_IMMEDIATE,	/* Prioritise for reclaim when writeback ends */
</span><span class="line">	NR_WRITEBACK_TEMP,	/* Writeback using temporary buffers */
</span><span class="line">	NR_ISOLATED_ANON,	/* Temporary isolated pages from anon lru */
</span><span class="line">	NR_ISOLATED_FILE,	/* Temporary isolated pages from file lru */
</span><span class="line">	NR_SHMEM,		/* shmem pages (included tmpfs/GEM pages) */
</span><span class="line">	NR_DIRTIED,		/* page dirtyings since bootup */
</span><span class="line">	NR_WRITTEN,		/* page writings since bootup */
</span><span class="line">#ifdef CONFIG_NUMA
</span><span class="line">	NUMA_HIT,		/* allocated in intended node */
</span><span class="line">	NUMA_MISS,		/* allocated in non intended node */
</span><span class="line">	NUMA_FOREIGN,		/* was intended here, hit elsewhere */
</span><span class="line">	NUMA_INTERLEAVE_HIT,	/* interleaver preferred this zone */
</span><span class="line">	NUMA_LOCAL,		/* allocation from local node */
</span><span class="line">	NUMA_OTHER,		/* allocation from other node */
</span><span class="line">#endif
</span><span class="line">	NR_ANON_TRANSPARENT_HUGEPAGES,
</span><span class="line">	NR_FREE_CMA_PAGES,
</span><span class="line">	NR_VM_ZONE_STAT_ITEMS };
</span></code></pre></td></tr></table></div></figure></notextile></div>

<h4 id="section">参考文章</h4>

<p><a href="http://kernel.taobao.org/index.php?title=Kernel_Documents/mm_sysctl">http://kernel.taobao.org/index.php?title=Kernel_Documents/mm_sysctl</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[linux应用内存占用maps分析]]></title>
    <link href="http://xixitalk.github.io/blog/2016/07/12/app-mem-used-on-linux/"/>
    <updated>2016-07-12T10:50:20+00:00</updated>
    <id>http://xixitalk.github.io/blog/2016/07/12/app-mem-used-on-linux</id>
    <content type="html"><![CDATA[<p>假设一个应用的pid是PID，则<code>cat /proc/PID/maps</code>显示这个应用的内存占用。</p>

<!--more-->

<h3 id="maps">maps格式</h3>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
</pre></td><td class="code"><pre><code class=""><span class="line">address           perms offset  dev   inode   pathname
</span><span class="line">00008000-00009000 r-xp 00000000 b3:02 317712     /home/pi/test/pmap/a.out
</span></code></pre></td></tr></table></div></figure></notextile></div>

<ol>
  <li><strong>address</strong> - This is the starting and ending address of the region in the process’s address space。说明：都是虚拟地址，并不代码真实的物理地址。</li>
  <li><strong>permissions</strong> - This describes how pages in the region can be accessed. There are four different permissions: read, write, execute, and shared. If read/write/execute are disabled, a ‘-‘ will appear instead of the ‘r’/’w’/’x’. If a region is not shared, it is private, so a ‘p’ will appear instead of an ‘s’. If the process attempts to access memory in a way that is not permitted, a segmentation fault is generated. Permissions can be changed using the <code>mprotect</code> system call.</li>
  <li><strong>offset</strong> - If the region was mapped from a file (using mmap), this is the offset in the file where the mapping begins. If the memory was not mapped from a file, it’s just 0.</li>
  <li><strong>device</strong> - If the region was mapped from a file, this is the major and minor device number (in hex) where the file lives.</li>
  <li><strong>inode</strong> - If the region was mapped from a file, this is the file number.</li>
  <li><strong>pathname</strong> - If the region was mapped from a file, this is the name of the file. This field is blank for anonymous mapped regions. There are also special regions with names like [heap], [stack], or [vdso]. [vdso] stands for virtual dynamic shared object. It’s used by system calls to switch to kernel mode. Here’s a good article about it.</li>
</ol>

<h3 id="section">实例分析</h3>

<p>写一个简单的实例main.c，funcA地址在代码段，s_buf在数据段，buf是局部变量，在栈空间，pheap是malloc申请的，是heap空间。</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
<span class="line-number">21</span>
<span class="line-number">22</span>
<span class="line-number">23</span>
<span class="line-number">24</span>
<span class="line-number">25</span>
<span class="line-number">26</span>
<span class="line-number">27</span>
</pre></td><td class="code"><pre><code class=""><span class="line">#include &lt;stdio.h&gt;
</span><span class="line">#include &lt;stdlib.h&gt;
</span><span class="line">#include &lt;unistd.h&gt;
</span><span class="line">
</span><span class="line">static char s_buf[1024];
</span><span class="line">void funcA(void)
</span><span class="line">{
</span><span class="line">  printf("funcA address:%08x\n",funcA);
</span><span class="line">}
</span><span class="line">
</span><span class="line">int main(int argc,char *argv[])
</span><span class="line">{
</span><span class="line">  int i = 0;
</span><span class="line">  char buf[1024] = {0};
</span><span class="line">  char *pheap = malloc(2048);
</span><span class="line">
</span><span class="line">  for(i=0;i&lt;1000;i++)
</span><span class="line">  {
</span><span class="line">    funcA();
</span><span class="line">    printf("buf address:%08x\n",buf);
</span><span class="line">    printf("s_buf address:%08x\n",s_buf);
</span><span class="line">    printf("pheap address:%08x\n",pheap);
</span><span class="line">    sleep(10);
</span><span class="line">  }
</span><span class="line">  free(pheap);
</span><span class="line">  return 0;
</span><span class="line">}
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>编译运行</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
</pre></td><td class="code"><pre><code class=""><span class="line">$gcc main.c
</span><span class="line">$./a.out
</span><span class="line">funcA address:000084a0
</span><span class="line">buf address:becb9318
</span><span class="line">s_buf address:000107ac
</span><span class="line">pheap address:01171008
</span><span class="line">funcA address:000084a0
</span><span class="line">buf address:becb9318
</span><span class="line">s_buf address:000107ac
</span><span class="line">pheap address:01171008
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>在另一个窗口</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
<span class="line-number">21</span>
<span class="line-number">22</span>
</pre></td><td class="code"><pre><code class=""><span class="line">$ ps aux | grep out
</span><span class="line">pi       27725  0.0  0.2   1676   424 pts/0    S+   10:43   0:00 ./a.out
</span><span class="line">$ cat /proc/27725/maps &gt; a.out.maps
</span><span class="line">$ cat a.out.maps
</span><span class="line">00008000-00009000 r-xp 00000000 b3:02 317712     /home/pi/test/pmap/a.out
</span><span class="line">00010000-00011000 rw-p 00000000 b3:02 317712     /home/pi/test/pmap/a.out
</span><span class="line">01171000-01192000 rw-p 00000000 00:00 0          [heap]
</span><span class="line">b6e36000-b6f59000 r-xp 00000000 b3:02 1925       /lib/arm-linux-gnueabihf/libc-2.13.so
</span><span class="line">b6f59000-b6f60000 ---p 00123000 b3:02 1925       /lib/arm-linux-gnueabihf/libc-2.13.so
</span><span class="line">b6f60000-b6f62000 r--p 00122000 b3:02 1925       /lib/arm-linux-gnueabihf/libc-2.13.so
</span><span class="line">b6f62000-b6f63000 rw-p 00124000 b3:02 1925       /lib/arm-linux-gnueabihf/libc-2.13.so
</span><span class="line">b6f63000-b6f66000 rw-p 00000000 00:00 0
</span><span class="line">b6f74000-b6f76000 r-xp 00000000 b3:02 27194      /usr/lib/arm-linux-gnueabihf/libcofi_rpi.so
</span><span class="line">b6f76000-b6f7d000 ---p 00002000 b3:02 27194      /usr/lib/arm-linux-gnueabihf/libcofi_rpi.so
</span><span class="line">b6f7d000-b6f7e000 rw-p 00001000 b3:02 27194      /usr/lib/arm-linux-gnueabihf/libcofi_rpi.so
</span><span class="line">b6f7e000-b6f9b000 r-xp 00000000 b3:02 1919       /lib/arm-linux-gnueabihf/ld-2.13.so
</span><span class="line">b6f9e000-b6fa2000 rw-p 00000000 00:00 0
</span><span class="line">b6fa2000-b6fa3000 r-xp 00000000 00:00 0          [sigpage]
</span><span class="line">b6fa3000-b6fa4000 r--p 0001d000 b3:02 1919       /lib/arm-linux-gnueabihf/ld-2.13.so
</span><span class="line">b6fa4000-b6fa5000 rw-p 0001e000 b3:02 1919       /lib/arm-linux-gnueabihf/ld-2.13.so
</span><span class="line">bec99000-becba000 rw-p 00000000 00:00 0          [stack]
</span><span class="line">ffff0000-ffff1000 r-xp 00000000 00:00 0          [vectors]
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>a.out.maps内容分析如下</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
</pre></td><td class="code"><pre><code class=""><span class="line">00008000-00009000 r-xp 00000000 b3:02 317712     /home/pi/test/pmap/a.out  
</span><span class="line">代码段，funcA在这个区间,权限是r-xp，有读、执行权限，p是private
</span></code></pre></td></tr></table></div></figure></notextile></div>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
</pre></td><td class="code"><pre><code class=""><span class="line">00010000-00011000 rw-p 00000000 b3:02 317712     /home/pi/test/pmap/a.out  
</span><span class="line">数据段，s_buf在这个区间,权限是rw-p，有读写，p是private
</span></code></pre></td></tr></table></div></figure></notextile></div>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
</pre></td><td class="code"><pre><code class=""><span class="line">01171000-01192000 rw-p 00000000 00:00 0          [heap]
</span><span class="line">堆空间，pheap在这个区间，权限是rw-p，有读写，p是private
</span></code></pre></td></tr></table></div></figure></notextile></div>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
</pre></td><td class="code"><pre><code class=""><span class="line">b6e36000-b6f59000 r-xp 00000000 b3:02 1925       /lib/arm-linux-gnueabihf/libc-2.13.so
</span><span class="line">libc库代码段
</span></code></pre></td></tr></table></div></figure></notextile></div>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
</pre></td><td class="code"><pre><code class=""><span class="line">b6f59000-b6f60000 ---p 00123000 b3:02 1925       /lib/arm-linux-gnueabihf/libc-2.13.so
</span><span class="line">libc库内存防止越界空间，权限是---p，没有rwx权限，用户访问就触发段错误
</span></code></pre></td></tr></table></div></figure></notextile></div>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
</pre></td><td class="code"><pre><code class=""><span class="line">b6f60000-b6f62000 r--p 00122000 b3:02 1925       /lib/arm-linux-gnueabihf/libc-2.13.so
</span><span class="line">libc库只读内存区。如果const变量，则在代码段；如果是全局变量则在数据段，还不知道这个区域内容。
</span></code></pre></td></tr></table></div></figure></notextile></div>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
</pre></td><td class="code"><pre><code class=""><span class="line">b6f62000-b6f63000 rw-p 00124000 b3:02 1925       /lib/arm-linux-gnueabihf/libc-2.13.so
</span><span class="line">libc库数据段
</span></code></pre></td></tr></table></div></figure></notextile></div>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
</pre></td><td class="code"><pre><code class=""><span class="line">b6f63000-b6f66000 rw-p 00000000 00:00 0
</span><span class="line">b6f9e000-b6fa2000 rw-p 00000000 00:00 0
</span><span class="line">未知，权限rw-p应该共享库相关的数据区
</span></code></pre></td></tr></table></div></figure></notextile></div>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
</pre></td><td class="code"><pre><code class=""><span class="line">b6f74000-b6f76000 r-xp 00000000 b3:02 27194      /usr/lib/arm-linux-gnueabihf/libcofi_rpi.so
</span><span class="line">b6f76000-b6f7d000 ---p 00002000 b3:02 27194      /usr/lib/arm-linux-gnueabihf/libcofi_rpi.so
</span><span class="line">b6f7d000-b6f7e000 rw-p 00001000 b3:02 27194      /usr/lib/arm-linux-gnueabihf/libcofi_rpi.so
</span><span class="line">b6f7e000-b6f9b000 r-xp 00000000 b3:02 1919       /lib/arm-linux-gnueabihf/ld-2.13.so
</span><span class="line">b6fa3000-b6fa4000 r--p 0001d000 b3:02 1919       /lib/arm-linux-gnueabihf/ld-2.13.so
</span><span class="line">b6fa4000-b6fa5000 rw-p 0001e000 b3:02 1919       /lib/arm-linux-gnueabihf/ld-2.13.so
</span><span class="line">同libc分析
</span></code></pre></td></tr></table></div></figure></notextile></div>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
</pre></td><td class="code"><pre><code class=""><span class="line">b6fa2000-b6fa3000 r-xp 00000000 00:00 0          [sigpage]
</span><span class="line">和信号相关的一个page，ARM架构独有好像
</span></code></pre></td></tr></table></div></figure></notextile></div>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
</pre></td><td class="code"><pre><code class=""><span class="line">bec99000-becba000 rw-p 00000000 00:00 0          [stack]
</span><span class="line">栈空间，局部变量buf在这个区间
</span></code></pre></td></tr></table></div></figure></notextile></div>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
</pre></td><td class="code"><pre><code class=""><span class="line">ffff0000-ffff1000 r-xp 00000000 00:00 0          [vectors]
</span><span class="line">中断向量
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>待完善…</p>

<h3 id="section-1">参考资料</h3>

<p><a href="http://stackoverflow.com/questions/1401359/understanding-linux-proc-id-maps">http://stackoverflow.com/questions/1401359/understanding-linux-proc-id-maps</a></p>

<p><a href="http://stackoverflow.com/questions/16524895/proc-pid-maps-shows-pages-with-no-rwx-permissions-on-x86-64-linux">http://stackoverflow.com/questions/16524895/proc-pid-maps-shows-pages-with-no-rwx-permissions-on-x86-64-linux</a></p>

<p><a href="https://yq.aliyun.com/articles/54405">https://yq.aliyun.com/articles/54405</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Linux内存占用分布分析]]></title>
    <link href="http://xixitalk.github.io/blog/2016/07/11/linux-mem-used/"/>
    <updated>2016-07-11T21:07:20+00:00</updated>
    <id>http://xixitalk.github.io/blog/2016/07/11/linux-mem-used</id>
    <content type="html"><![CDATA[<h2 id="section">1. 内存占用</h2>

<p>linux内存占用分两部分：一部分是不可见的，内核代码段数据段的本身的占用空间，对于PC 上几个G的内存来说可能很小可以忽略不计，但是只有几十M内存的嵌入式环境来说就不能忽略了。另一部分就是linux系统可见的内存，<code>free</code>命令里的<code>total</code>或者<code>cat /proc/meminfo</code>里看到的<code>MemTotal</code>。</p>

<!--more-->

<h3 id="section-1">1.1 内核代码段数据段</h3>
<p>通过内核对应带调试信息文件vmlinux或者System.map文件，能查到如下符号：<code>_stext</code> <code>_etext</code>  <code>__bss_start</code>  <code>__bss_stop</code> <code>_end</code>。   <code>__bss_stop</code> <code>_end</code>值是一样的。<code>_etext</code> 减<code>_stext</code>就是代码段大小，  <code>__bss_stop</code>减<code>__bss_start</code> 就是数据段大小。代码段和数据段之前的空间是<code>Init</code>段，内核初始化只运行一次的代码放在这个段，内核初始化后会重新覆盖利用这块空间。</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
</pre></td><td class="code"><pre><code class=""><span class="line">_stext                     C0008160
</span><span class="line">_etext                     C051B958   代码段大小：0x5137F8 
</span><span class="line">__bss_start                C05872E4
</span><span class="line">__bss_stop                 C060EBF0   数据段大小：0x8790C 
</span><span class="line">_end                       C060EBF0 
</span></code></pre></td></tr></table></div></figure></notextile></div>

<h3 id="linux">1.2 linux系统管理内存</h3>

<p>linux系统可见的内存，<code>free</code>命令里的<code>total</code>或者<code>cat /proc/meminfo</code>里看到的<code>MemTotal</code>。内存管理太复杂了，完整拼接出来<code>total</code>或者<code>MemTotal</code>几乎不可能，但可以有几个重要的部分。</p>

<h4 id="section-2">1.2.1 空闲内存</h4>

<p>空闲内存：meminfo(cat /proc/meminfo)里的<code>MemFree</code> + <code>Buffers</code> + <code>Cached</code> + <code>SwapCached</code></p>

<h4 id="section-3">1.2.2 内核内存占用</h4>

<p>内核内存占用：meminfo(cat /proc/meminfo)里的<code>Slab</code> + <code>KernelStack</code> + <code>PageTables</code></p>

<h4 id="section-4">1.2.3 应用内存占用</h4>

<p>应用内存有两个视图，一个是虚拟内存视图，一个物理内存（RSS）视图。
比如查看进程编号为1的Init进程内存占用</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
</pre></td><td class="code"><pre><code class=""><span class="line">$cat /pric/1/statm
</span><span class="line">537 18 11 7 0 75 0
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>537是虚拟内存的page数，18是物理内存page数，每个page是4K Bytes。</p>

<p>用下面的脚本可以把系统所有应用的虚拟内存和物理内存统计出来，应用间的内存比较分析是有意义的或者同一个应用不同版本间的比较是有意义的。</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
</pre></td><td class="code"><pre><code class=""><span class="line">#/bin/bash
</span><span class="line">RSS=0
</span><span class="line">VM=0
</span><span class="line">for PROC in `ls /proc/|grep "^[0-9]"`
</span><span class="line">do
</span><span class="line">  if [ -f /proc/$PROC/statm ]; then
</span><span class="line">      TEP1=`cat /proc/$PROC/statm | awk '{print ($1)}'`
</span><span class="line">      TEP2=`cat /proc/$PROC/statm | awk '{print ($2)}'`
</span><span class="line">      echo $PROC $TEP1 $TEP2
</span><span class="line">      RSS=`expr $RSS + $TEP2`
</span><span class="line">      VM=`expr $VM + $TEP1`
</span><span class="line">  fi
</span><span class="line">done
</span><span class="line">RSS=`expr $RSS \* 4`
</span><span class="line">VM=`expr $VM \* 4`
</span><span class="line">
</span><span class="line">echo "APP total" $RSS"KB", $VM"KB",
</span></code></pre></td></tr></table></div></figure></notextile></div>

<h2 id="section-5">2. 参考资料</h2>

<p>http://blog.yufeng.info/archives/2456</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[我的AStyle配置选项]]></title>
    <link href="http://xixitalk.github.io/blog/2016/07/11/my-AStyle-config/"/>
    <updated>2016-07-11T18:35:57+00:00</updated>
    <id>http://xixitalk.github.io/blog/2016/07/11/my-AStyle-config</id>
    <content type="html"><![CDATA[<p>我的AStyle代码格式工具的选项：AStyle.exe -A1 -C -S -K -Y -f -t -p -U -o -n main.c</p>

<p>在<code>notepad++</code>里添加：<code>运行(R)--运行(R)</code> 选择AStyle.exe，选项输入<code>-A1 -C -S -K -Y -f -t -p -U -o -n "$(FULL_CURRENT_PATH)"</code>，然后点击<code>保存</code>，这样就保存在运行菜单里了。每次使用从<code>运行(R)</code>点击即可。</p>

<!--more-->

<p>简略选项：<code>-A1 -C -S -K -Y -f -t -p -U -o -n</code>
对应长选项如下：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
</pre></td><td class="code"><pre><code class=""><span class="line">--style=bsd
</span><span class="line">--indent-classes
</span><span class="line">--indent-switches
</span><span class="line">--indent-cases
</span><span class="line">--indent-col1-comments
</span><span class="line">--break-blocks
</span><span class="line">--indent=tab
</span><span class="line">--pad-oper
</span><span class="line">--unpad-paren
</span><span class="line">--keep-one-line-statements
</span><span class="line">--suffix=none
</span></code></pre></td></tr></table></div></figure></notextile></div>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[函数栈破坏检查]]></title>
    <link href="http://xixitalk.github.io/blog/2016/07/09/func-stack-check/"/>
    <updated>2016-07-09T14:49:35+00:00</updated>
    <id>http://xixitalk.github.io/blog/2016/07/09/func-stack-check</id>
    <content type="html"><![CDATA[<p>函数栈破坏检查 平台 ARM linux，编译器GCC</p>

<!--more-->

<p>产品部分音频功能是台湾某家公司提供的，开源了部分代码，二次开发实现一个功能发现偶现程序段错误，根据coredump显示最后异常函数是一个类似printf的打印函数，而这个打印函数基本可以肯定是没有问题的，并且出现了多次。程序这样跑飞其中一个可能的原因就是函数栈遭到破坏，函数执行完弹栈返回函数调用的下条指令时候出错了。所以写了一个函数栈检查函数。</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
</pre></td><td class="code"><pre><code class=""><span class="line">funcA()
</span><span class="line">{
</span><span class="line">	funcB()
</span><span class="line">	RETURN_EXP
</span><span class="line">}
</span><span class="line">
</span><span class="line">funcB()
</span><span class="line">{
</span><span class="line">	funcC();
</span><span class="line">	funcD();
</span><span class="line">	funcE();
</span><span class="line">}
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>原理：函数调用过程是进函数funcB把调用funcB地方的下一条指令地址RETURN_EXP_ADDR（RETURN_EXP语句的地址）压栈，funcB函数执行完弹栈从栈把RETURN_EXP_ADDR赋值给PC就完成了函数返回，funcB函数在返回之前栈里的返回地址RETURN_EXP_ADDR一直在栈里，而funcB函数里本身可能会再调用多个其他函数，这些函数funcC、funcD和funcE都不应该擦写函数funcB的返回地址RETURN_EXP_ADDR。进funcB开始，就把RETURN_EXP_ADDR地址从栈里找出来，funcC、funcD和funcE执行完了都检查一下栈里的RETURN_EXP_ADDR是否被破坏。</p>

<script src="https://gist.github.com/xixitalk/633303a13cd3711b4efc94881e1cc0da.js"></script>

<p>问题很快定位，问题原因是其中一个函数接收消息的时候，recv函数输入可接收数据size比buffer实际size大，大小都是宏值，不容易发觉，这个buffer恰好是局部变量（栈空间），从而recv长消息的时候把栈破坏了。</p>

<p>特别提醒：如果定位的testFunc函数里局部变量过大，可能需要调整STACK_FIND_SIZE大小。定位平台是ARM linux，编译是GCC，其他平台和编译器以此类推。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[malloc封装检查越界]]></title>
    <link href="http://xixitalk.github.io/blog/2016/07/09/malloc-wrap/"/>
    <updated>2016-07-09T13:32:35+00:00</updated>
    <id>http://xixitalk.github.io/blog/2016/07/09/malloc-wrap</id>
    <content type="html"><![CDATA[<p>malloc封装检查越界</p>

<!--more-->

<p>上周出差，出现一例死机现场在libc的malloc函数里，分析malloc管理内存被擦写了，想来应该是用户使用malloc越界了。但是问题难复现，程序运行大于6小时出现，共抓取了3个现场，死机位置类似，可以定位某个线程的while循环。所以现场封装了一个malloc函数用于检测内存是否越界。代码如下</p>

<script src="https://gist.github.com/xixitalk/d9364ee670f09f0365fd45466a773ba4.js"></script>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
</pre></td><td class="code"><pre><code class=""><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</span><span class="line">|  size | BEGIN_MAGIC |      USER      BUFFER      | END_MAGIC |
</span><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>每次内存申请多申请12个字节，前4个字节保存用户真实size，第4-8个字节保存魔术字，最后4个字节也保存魔术字，起始地址+8是用户可见的空间。</p>

<p>很快就定位某个函数使用缓存越界了。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[UINT32引起的死循环]]></title>
    <link href="http://xixitalk.github.io/blog/2016/07/09/dead-loop-UINT32/"/>
    <updated>2016-07-09T10:02:35+00:00</updated>
    <id>http://xixitalk.github.io/blog/2016/07/09/dead-loop-UINT32</id>
    <content type="html"><![CDATA[<p>UINT32 引起的死循环</p>

<!--more-->

<p>上周出差定位一个死循环。一个函数进行一个信号量的初始化，每次进行一次业务都要调用这个函数初始化，这个函数作用是保障初始化后信号量初始化值为<code>SEM_INIT_NUM</code>，但因为<code>UINT32</code>的关系出现死循环了。代码如下：</p>

<script src="https://gist.github.com/xixitalk/5c176a78a8743465061ef15ab5f9a248.js"></script>

<p>出现问题的时候，<code>semCount</code>为4，而宏<code>SEM_INIT_NUM</code>为3，造成<code>Count = SEM_INIT_NUM - semCount</code>为<code>-1</code>了，但因为<code>Count</code>是<code>UINT32</code>，从而变成<code>0xFFFFFFFF</code>，一个极大值，造成for循环执行长时间不退出。修改方法是将<code>Count</code>的<code>UINT32</code>改成<code>SINT32</code>。这是一个非常低级的代码错误。</p>

<p>其实更简单的是删除信号量，重新创建信号量，这样代码会容易读的多。</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
</pre></td><td class="code"><pre><code class=""><span class="line">DeleteSemaphore(ptxSem);
</span><span class="line">ptxSem = CreateSemaphore(SEM_INIT_NUM);
</span></code></pre></td></tr></table></div></figure></notextile></div>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Nexus 6P上用flashfire升级系统]]></title>
    <link href="http://xixitalk.github.io/blog/2016/06/12/flashfire-nexus-6p/"/>
    <updated>2016-06-12T10:53:35+00:00</updated>
    <id>http://xixitalk.github.io/blog/2016/06/12/flashfire-nexus-6p</id>
    <content type="html"><![CDATA[<p>Nexus 6P上用flashfire升级系统</p>

<p>问题：Nexus原生系统root后怎么升级到最新系统？</p>

<!--more-->

<p>适用场景：nexus原生系统只是root，安装了superSU，其他系统文件没有修改，安装Xposed的情况我没有尝试过。</p>

<p>我的Nexus 6P本来系统是没有root的，每个月都通过OTA升级到最新系统，但是后来实在忍受不了国产应用间的相互唤醒了，root了系统，recovery换成了TWRP 3.0，使用了冰箱(icebox)把几个国产的应用冷冻起来了。其他系统文件没有修改。六月份系统推送了6月安全补丁MTC19V，一直在系统通知栏提示，甚是碍眼。搜索了一下发现可以使用flashfire更新系统。</p>

<p>参考教程 <a href="http://bbs.mgyun.com/thread-50136-1-1.html">华为 Nexus 6p 教你nexus手机root后怎么更新，就像ota一样，转自国外大神chainfire</a> </p>

<p>于是从google Play上下载了最新版本的flashfire，用方法2升级了系统。</p>

<h2 id="flashfireota">方法1：flashfire直接OTA升级</h2>

<p>按照flashfire的说明，系统下载完OTA升级包不要在<code>设置</code>里重启系统升级，打开flashfire会自动探测到OTA，直接一路确定升级。但是我尝试升级MTC19V没有成功，尝试了两次，系统重启进flashfire升级后系统版本号还是MTC19T，不是MTC19V。</p>

<h2 id="flashfire">方法2：flashfire刷整个新系统</h2>

<p>方法2的理论是android系统在system分区，系统运行时候是只读的，用户产生的数据和配置都在data分区，OTA补丁是打到system分区的，所以升级新系统升级system分区而不覆盖data分区就达到了升级补丁还不破坏用户数据作用。</p>

<ol>
  <li>先把冰箱里冷冻的所有应用全部解冻。</li>
  <li>从<a href="https://developers.google.com/android/nexus/images">https://developers.google.com/android/nexus/images</a>下载最新的MTC19V版本，有900多M，扩展名以tgz结尾：angler-mtc19v-factory-5c289974.tgz。</li>
  <li>把angler-mtc19v-factory-5c289974.tgz拷贝到手机里。</li>
  <li>打开flashfire，点击+，点击<code>Flash firmware package</code>，选择手机里angler-mtc19v-factory-5c289974.tgz。</li>
  <li>flashfire会分析tgz包，手动选择刷入Boot、system、vendor和cache分区，<strong>recovery和data不选择</strong>，切记。recovery就是twrp，data是用户安装的应用，不刷data是保留用户安装的应用。</li>
  <li>添加之后，flashfire会在EverRoot里自动添加刷入SuperSU，系统更新完成自动root。</li>
  <li>点击flash，系统自动关机重启进入flashfire刷入系统。</li>
  <li>flashfire更新之后系统自动重启，可以从设置里看到版本号已经是MTC19V了。</li>
</ol>

<p>更新：7月份升级MTC19X的时候截了几张图。</p>

<p><img src="http://xixitalkgithubio.qiniudn.com/partition_mini.jpg" alt="enter image description here" /></p>

<p><img src="http://xixitalkgithubio.qiniudn.com/flash_mini.jpg" alt="enter image description here" /></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[在树莓派上安装SigmaVPN]]></title>
    <link href="http://xixitalk.github.io/blog/2016/05/07/Install-SigmaVPN-on-Raspbian/"/>
    <updated>2016-05-07T20:27:44+00:00</updated>
    <id>http://xixitalk.github.io/blog/2016/05/07/Install-SigmaVPN-on-Raspbian</id>
    <content type="html"><![CDATA[<p>Install SigmaVPN on Raspbian<br />
在树莓派上安装SigmaVPN</p>

<!--more-->

<h1 id="android-sigmavpnfailsigmavpnbugshadowsocksandroid">以下配置还有一些问题待解决：从Android SigmaVPN连接服务器，提示数据解密FAIL，问题原因未知，我觉得是sigmaVPN软件的BUG。最后我架了一个Shadowsocks服务器，android手机上用影梭全局访问，在外面可以访问家里全部局域网资源。</h1>

<h2 id="sigmavpn">获取SigmaVPN代码</h2>

<p>从github获取代码</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class=""><span class="line">git clone https://github.com/neilalexander/sigmavpn.git
</span></code></pre></td></tr></table></div></figure></notextile></div>

<h2 id="libsodium">安装libsodium</h2>

<p>SigmaVPN依赖libsodium，安装libsodium</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class=""><span class="line">sudo apt-get install libsodium-dev
</span></code></pre></td></tr></table></div></figure></notextile></div>

<h2 id="sigmavpn-1">编译SigmaVPN</h2>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
</pre></td><td class="code"><pre><code class=""><span class="line">$cd sigmavpn
</span><span class="line">$make
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>显示以下编译信息，编译完成，没有想到编译如此简单顺利。</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
</pre></td><td class="code"><pre><code class=""><span class="line">cc -I/usr/local/include -O2 -fPIC -Wall -Wextra -c naclkeypair.c -o naclkeypair.o
</span><span class="line">cc -I/usr/local/include -O2 -fPIC -Wall -Wextra -c pack.c -o pack.o
</span><span class="line">cc -I/usr/local/include -O2 -fPIC -Wall -Wextra -c tai.c -o tai.o
</span><span class="line">cc -o naclkeypair naclkeypair.o -L/usr/local/lib -lsodium -ldl -pthread
</span><span class="line">cc -o sigmavpn main.o modules.o dep/ini.o -L/usr/local/lib -lsodium -ldl -pthread
</span><span class="line">cc -I/usr/local/include -I/usr/local/include proto/proto_raw.c -o proto/proto_raw.o -O2 -fPIC -Wall -Wextra -shared -L/usr/local/lib -lsodium
</span><span class="line">cc -I/usr/local/include -I/usr/local/include proto/proto_nacl0.c pack.o -o proto/proto_nacl0.o -O2 -fPIC -Wall -Wextra -shared -L/usr/local/lib -lsodium
</span><span class="line">cc -I/usr/local/include -I/usr/local/include proto/proto_nacltai.c pack.o tai.o -o proto/proto_nacltai.o -O2 -fPIC -Wall -Wextra -shared -L/usr/local/lib -lsodium
</span><span class="line">cc -I/usr/local/include intf/intf_tuntap.c -o intf/intf_tuntap.o -O2 -fPIC -Wall -Wextra -shared
</span><span class="line">cc -I/usr/local/include intf/intf_udp.c -o intf/intf_udp.o -O2 -fPIC -Wall -Wextra -shared
</span></code></pre></td></tr></table></div></figure></notextile></div>

<h2 id="sigmavpn-2">sigmavpn执行环境</h2>

<p>sigmavpn不安装，把需要的可执行程序提取出来。sigmavpn支持模块化，需要<code>proto</code>和<code>intf</code>里的几个<code>.o</code>文件。</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
</pre></td><td class="code"><pre><code class=""><span class="line">mkdir -p ~/tools/sigmavpn
</span><span class="line">cp naclkeypair  ~/tools/sigmavpn/
</span><span class="line">cp sigmavpn     ~/tools/sigmavpn/
</span><span class="line">cp ./proto/*.o  ~/tools/sigmavpn/
</span><span class="line">cp ./intf/*.o   ~/tools/sigmavpn/
</span></code></pre></td></tr></table></div></figure></notextile></div>

<h2 id="sigmavpn-3">SigmaVPN配置</h2>

<p>我参考的是clowwindy的配置 <a href="https://gist.github.com/clowwindy/57d44b69741992d3eaa3">https://gist.github.com/clowwindy/57d44b69741992d3eaa3</a></p>

<p>还有这个<a href="http://workiis.blogspot.com/2015/03/sigmavpn-android-setup.html">Workiis: SigmaVPN Android Setup</a></p>

<h3 id="protopublickeyprotoprivatekey">生成proto_publickey和proto_privatekey</h3>

<p>运行<code>naclkeypair</code>生成proto_publickey和proto_privatekey。</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
</pre></td><td class="code"><pre><code class=""><span class="line">cd ~/tools/sigmavpn/
</span><span class="line">./naclkeypair
</span></code></pre></td></tr></table></div></figure></notextile></div>

<h3 id="vpnconf">创建vpn.conf</h3>

<p>其中192.168.1.104是树莓派的IP，如果是VPS则换成VPS的公网IP。proto_publickey和proto_privatekey替换成上面的生成的值。</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
</pre></td><td class="code"><pre><code class=""><span class="line">[mysigmavpn]
</span><span class="line">proto = nacltai
</span><span class="line">proto_publickey = ce499073fc29bda865d0e0a4a4cf82428252409734de4691242804e45fa67e3d
</span><span class="line">proto_privatekey = 76db698a3ef69b0e1158a4cb238ee72a1cc5d30ed1c6fadeaa4c62549e02d95d
</span><span class="line">local = tuntap
</span><span class="line">local_interface = tunnel
</span><span class="line">local_tunmode = 1
</span><span class="line">peer = udp
</span><span class="line">peer_localaddr = 192.168.1.104
</span><span class="line">peer_localport = 5678
</span><span class="line">peer_remotefloat = 1
</span></code></pre></td></tr></table></div></figure></notextile></div>

<h3 id="tunneliptables">创建tunnel网口和配置iptables</h3>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
</pre></td><td class="code"><pre><code class=""><span class="line">sudo ip tuntap add dev tunnel mode tun
</span><span class="line">sudo ifconfig tunnel 10.8.0.1/24
</span><span class="line">sudo ifconfig tunnel mtu 1440
</span><span class="line">sudo echo 1 &gt; /proc/sys/net/ipv4/ip_forward
</span><span class="line">sudo iptables -t nat -A POSTROUTING -o eth0 -j MASQUERADE
</span><span class="line">sudo iptables -A FORWARD -i eth0 -o tunnel -m state --state RELATED,ESTABLISHED -j ACCEPT
</span><span class="line">sudo iptables -A FORWARD -i tunnel -o eth0 -j ACCEPT
</span><span class="line">sudo iptables -t mangle -A FORWARD -p tcp --tcp-flags SYN,RST SYN -j TCPMSS --set-mss 1400
</span></code></pre></td></tr></table></div></figure></notextile></div>

<h3 id="sigmavpn-4">启动sigmavpn</h3>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class=""><span class="line">./sigmavpn -c vpn.conf -m . &amp;
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>-m指定模块<code>.o</code>所在的目录。</p>

<h2 id="androidsigmavpn">配置android上sigmavpn客户端</h2>

<p>在市场安装sigmavpn客户端。</p>

<h3 id="tunnel">TUNNEL配置</h3>

<p>Remote Address : vpn.conf里的peer_localaddr<br />
Remote Port : vpn.conf里的peer_localport<br />
Remote Public Key: vpn.conf里的proto_publickey  </p>

<p>选中Use TAI64 nonce</p>

<h3 id="network">NETWORK配置</h3>

<p>Tunnel Address Prefix：10.8.0.2/24  </p>

<p>配置完成后，点击STATUS页的CONNECT按钮，看看状态栏是不是有VPN的小钥匙了。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Install owncloud 9.0.2 on RaspberryPi]]></title>
    <link href="http://xixitalk.github.io/blog/2016/04/22/Install-owncloud-on-raspberrypi/"/>
    <updated>2016-04-22T23:16:41+00:00</updated>
    <id>http://xixitalk.github.io/blog/2016/04/22/Install-owncloud-on-raspberrypi</id>
    <content type="html"><![CDATA[<p>Install owncloud 9.0.2 on RaspberryPi<br />
在树莓派上安装owncloud 9.0.2</p>

<!--more-->

<h1 id="section">系统环境</h1>

<p>我用的硬件是树莓派3，系统是<code>raspbian JESSIE LITE</code>，下载地址<a href="https://www.raspberrypi.org/downloads/raspbian/">https://www.raspberrypi.org/downloads/raspbian/</a>，我是新系统全新安装<code>owncloud</code>，仅供参考。</p>

<p>首先配置系统扩展到整个SD卡，配置后重启系统才生效。</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class=""><span class="line">sudo raspi-config 
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>更新<code>apt</code>软件仓库，升级系统到最新，可以修改<code>/etc/apt/source.list</code>使用aliyun的源。</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
</pre></td><td class="code"><pre><code class=""><span class="line">sudo apt-get update
</span><span class="line">sudo apt-get dist-upgrade
</span></code></pre></td></tr></table></div></figure></notextile></div>

<h1 id="owncloud">owncloud官方安装文档</h1>

<p>这里是<code>owncloud 9.0</code>版本的官方安装文档,供参阅：<a href="https://doc.owncloud.org/server/9.0/admin_manual/installation/source_installation.html">https://doc.owncloud.org/server/9.0/admin_manual/installation/source_installation.html</a></p>

<h1 id="section-1">安装过程</h1>

<h2 id="apache2-phpmariadb">第一步：安装apache2 php和mariadb数据库</h2>

<p>安装<code>owncloud</code>所需要的<code>apache</code> <code>php</code> 和<code>mariadb</code>数据库软件，安装过程会提示配置<code>mariadb</code>数据库的<code>root</code>账号密码，牢记这个密码。</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class=""><span class="line">sudo apt-get install apache2 mariadb-server libapache2-mod-php5 php5-gd php5-json php5-mysql php5-curl php5-intl php5-mcrypt php5-imagick
</span></code></pre></td></tr></table></div></figure></notextile></div>

<h2 id="owncloud-1">第二步：下载owncloud软件包</h2>

<p>下载<code>owncloud</code>软件包，并解压，即发现<code>owncloud</code>目录。</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
</pre></td><td class="code"><pre><code class=""><span class="line">wget https://download.owncloud.org/community/owncloud-9.0.1.tar.bz2
</span><span class="line">tar -xjf owncloud-9.0.1.tar.bz2
</span></code></pre></td></tr></table></div></figure></notextile></div>

<h2 id="owncloudapache2">第三步：为owncloud配置apache2</h2>

<p>拷贝<code>owncloud</code>代码到<code>apache2</code>的网站根目录</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class=""><span class="line">sudo cp -r owncloud /var/www
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>为<code>apache2</code>添加<code>owncloud.conf</code>配置文件</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class=""><span class="line">sudo vi /etc/apache2/sites-available/owncloud.conf
</span></code></pre></td></tr></table></div></figure></notextile></div>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
</pre></td><td class="code"><pre><code class=""><span class="line">Alias /owncloud "/var/www/owncloud/"
</span><span class="line">
</span><span class="line">&lt;Directory /var/www/owncloud/&gt;
</span><span class="line">  Options +FollowSymlinks
</span><span class="line">  AllowOverride All
</span><span class="line">
</span><span class="line"> &lt;IfModule mod_dav.c&gt;
</span><span class="line">  Dav off
</span><span class="line"> &lt;/IfModule&gt;
</span><span class="line">
</span><span class="line"> SetEnv HOME /var/www/owncloud
</span><span class="line"> SetEnv HTTP_HOME /var/www/owncloud
</span><span class="line">
</span><span class="line">&lt;/Directory&gt;
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>将<code>sites-enabled</code>里<code>owncloud.conf</code>软连接到<code>sites-available</code>的<code>owncloud.conf</code></p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class=""><span class="line">sudo ln -s /etc/apache2/sites-available/owncloud.conf /etc/apache2/sites-enabled/owncloud.conf
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>打开<code>apache2</code>里<code>owncloud</code>所需的模块</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
</pre></td><td class="code"><pre><code class=""><span class="line">sudo a2enmod rewrite
</span><span class="line">sudo a2enmod headers
</span><span class="line">sudo a2enmod env
</span><span class="line">sudo a2enmod dir
</span><span class="line">sudo a2enmod mime
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>重启<code>apache2</code>服务</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class=""><span class="line">sudo service apache2 restart
</span></code></pre></td></tr></table></div></figure></notextile></div>

<h2 id="occowncloud">第四步：用occ安装owncloud剩余部分</h2>

<p>这一部分可以参考官方文档<a href="https://doc.owncloud.org/server/9.0/admin_manual/installation/command_line_installation.html">https://doc.owncloud.org/server/9.0/admin_manual/installation/command_line_installation.html</a></p>

<p>改变<code>/var/www/owncloud</code>目录的用户属性</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class=""><span class="line">sudo chown -R www-data:www-data /var/www/owncloud/
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>用<code>occ</code>安装<code>owncloud</code>，<code>database-pass</code>即为数据库的<code>root</code>用户密码，<code>admin</code>和<code>password</code>是<code>owncloud</code>的用户帐号和密码，牢记。</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class=""><span class="line">$ cd /var/www/owncloud/
</span></code></pre></td></tr></table></div></figure></notextile></div>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
</pre></td><td class="code"><pre><code class=""><span class="line">$ sudo -u www-data php occ  maintenance:install --database
</span><span class="line">"mysql" --database-name "owncloud"  --database-user "root" --database-pass
</span><span class="line">"password" --admin-user "admin" --admin-pass "password"
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>会提示以下信息</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
</pre></td><td class="code"><pre><code class=""><span class="line">ownCloud is not installed - only a limited number of commands are available
</span><span class="line">ownCloud was successfully installed
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>添加IP或者域名到<code>config.php</code>的可信域<code>trusted_domains</code>。</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class=""><span class="line">sudo vi /var/www/owncloud/config/config.php
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>类似下面格式</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
</pre></td><td class="code"><pre><code class=""><span class="line">  'trusted_domains' =&gt;
</span><span class="line">  array (
</span><span class="line">    0 =&gt; 'localhost',
</span><span class="line">    1 =&gt; '192.168.1.104',
</span><span class="line">    2 =&gt; '192.168.1.106',
</span><span class="line">  ),
</span></code></pre></td></tr></table></div></figure></notextile></div>

<h2 id="owncloud-2">第五步：浏览器打开owncloud</h2>

<p>用浏览器访问owncloud的地址，Enjoy owncloud!</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class=""><span class="line">http://RaspberryPi-IP/owncloud
</span></code></pre></td></tr></table></div></figure></notextile></div>

<h1 id="todo">TODO</h1>

<ol>
  <li>没有配置SSL</li>
  <li>安全的配置目录权限</li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[高度近视眼底例行检查]]></title>
    <link href="http://xixitalk.github.io/blog/2014/06/29/fundus-examination/"/>
    <updated>2014-06-29T21:32:13+00:00</updated>
    <id>http://xixitalk.github.io/blog/2014/06/29/fundus-examination</id>
    <content type="html"><![CDATA[<blockquote><p>感谢金葡萄老师 @goldengrape 的洗脑，高度近视每半年复查眼底。今天查出来双眼视网膜裂孔（只有一点点大，首诊的医生拿不准说疑似，主任看了才确认的），做了激光光凝术（听起来有点像魔法，笑~）。</p><footer><strong>如月中天(‏@gttnnn)</strong> <cite><a href="https://twitter.com/gttnnn/status/474409944809095168">twitter.com/gttnnn/status/&hellip;</a></cite></footer></blockquote>

<p>推上说高度近视（wiki上说大于600度）需要每半年做眼底例行检查，我自己也高度近视，所以周六去<strong>南京医科大学附属眼科医院</strong>做了眼底检查，右眼发现视网膜有<strong>裂孔</strong>，预约了周一做<strong>视网膜激光光凝术</strong>。现在把过程流水帐记录下来，半年之后再检查可能用得上。</p>

<!--more-->

<h2 id="section">准备物特别提醒</h2>
<p>医保卡要带上，最好带个<strong>kindle和耳机</strong>，kindle在候诊排队的时候可以看书，很多医院排队很凶残的，特别是周末。深入检查眼底需要滴<strong>散瞳</strong>眼药水，散瞳之后4-6小时内看近距离物体模糊,看手机屏幕重影，根本看不清，在室外需要眯着眼睛很难睁开，所以可以带个耳机听音乐。还有不要<strong>开车</strong>。更细心的可以戴个口罩，毕竟候诊时候有染上细菌病毒的风险。</p>

<h2 id="section-1">就医</h2>
<p>下面是在南京医科大学附属眼科医院的就医过程，不在南京的可以忽略。<br />
南京医科大学附属眼科医院在地铁<strong>上海站</strong>附近，从2号出口出来即到。挂号就诊拿药都在一个大厅里。<br />
先去挂号，挂完号后把病历和挂号单交给护士站排队（人工排队，不要直接去科室），然后在护士站前面找个座位坐下，如果轮到你护士会用一个类似导游的小喇叭喊你的名字。护士喊你的名字后，你要问清是几号科室（科室标记不明显,我找了两圈）。找到科室后直接进科室，虽然前面有人正在看病，你也要把病历放在医生的桌子上排队，先放先看，不要傻等。轮到你告诉医生做高度近视眼底检查，他会初步检查，再开检查单，你拿着检查单去挂号处缴费，缴费后先去测试眼压，然后去护士站滴散瞳眼药水，等待散瞳，大约10分钟，护士说可以了，你就再去医生那里。医生检查后如果没问题就可以直接回家，此时费用在100块钱以内。<br />
如果医生告诉你视网膜有裂孔，会给你开<strong>眼底照相</strong>和<strong>视网膜激光光凝术</strong>的单子，拿着单子去缴费，缴费后去后面大楼一楼护士站。那里护士会安排你先去做眼底照相，并预约视网膜激光光凝术。眼底照相完成后会现场打印照片。做光凝术的时候，把病历和眼底照片带上。<br />
PS：眼底检查很简单，可以到方便的医院做，没必非要去最好的眼科医院，我下次准备去鼓楼医院，南京医科大学附属眼科医院乱糟糟的，像菜市场一样（可能新大楼还在装修）。</p>

<h2 id="section-2">视网膜激光光凝术</h2>
<p>眼底照相（加照片）30￥多，视网膜激光光凝术费用是400￥。手术前护士先你给滴<strong>散瞳</strong>眼药水，然后滴麻醉眼药水，此为手术前的准备工作（大约20分钟），手术大约10分钟，当激光射入眼睛的时候稍微有些疼痛。因为会散瞳所以不要开车。做完手术两个星期内减少用眼，两个星期后去复查。</p>

<h2 id="section-3">平常注意</h2>
<p>除了定时做眼底检查之外，平常还应该注意以下几点：</p>

<ul>
  <li>佩戴合适的眼镜</li>
  <li>不要长时间对着电脑或者手机，严禁通宵打游戏上网</li>
  <li>避免剧烈撞击的活动</li>
  <li>同时有高血压或者糖尿病更多危险，需要更多注意</li>
  <li>避免将眼球过度转动眼睛最边缘，翻白眼、轻蔑、鄙视的眼神都要少做</li>
</ul>

<h2 id="section-4">外部参考资料</h2>
<p>1.<a href="http://www.kqeye.com/article/2164.html">高度近视 眼底检查很重要</a><br />
2.<a href="http://cht.a-hospital.com/w/%E9%AB%98%E5%BA%A6%E8%BF%91%E8%A7%86">高度近视</a>  </p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[免费申请S/MIME证书]]></title>
    <link href="http://xixitalk.github.io/blog/2014/06/21/Free-SMIME-Certificate-Key/"/>
    <updated>2014-06-21T00:05:11+00:00</updated>
    <id>http://xixitalk.github.io/blog/2014/06/21/Free-SMIME-Certificate-Key</id>
    <content type="html"><![CDATA[<h2 id="section">申请证书</h2>
<p>从这里可以申请到免费的S/MIME 邮件证书：<a href="http://www.instantssl.com/ssl-certificate-products/free-email-certificate.html">http://www.instantssl.com/ssl-certificate-products/free-email-certificate.html</a>，
提交生成之后会把证书发送到邮箱里。</p>

<h2 id="section-1">证书安装</h2>
<p>在邮箱里点击连接就会把证书安装到电脑系统中（包括windows和Mac OSX)。<br />
证书认证关系如下：  </p>

<ul>
  <li>第一级根证书USERTrust(UTN-USERFirst-Client Authentication and Email)，系统中默认都带了；</li>
  <li>第二级中级证书是COMODO Client Authentication and Secure Email CA;</li>
  <li>第三级才是刚刚申请的个人证书。<br />
如果在证书管理器查看刚刚申请的个人证书显示不正常的话，说明系统中缺少第二级中级证书，从这里下载安装<a href="http://crt.comodoca.com/COMODOClientAuthenticationandSecureEmailCA.crt">http://crt.comodoca.com/COMODOClientAuthenticationandSecureEmailCA.crt</a>。</li>
</ul>

<h2 id="ios">证书安装到iOS系统</h2>
<p>在电脑系统里打开证书管理器（windows系统是运行certmgr.msc），把证书（包含私钥）导出，windows是pfx格式，Mac OSX是p12格式，导出的证书要设置私钥保护密码，iOS的证书安装需要输入这个密码。把这个pfx或者p12格式的证书发邮件到iOS上，点击打开即提示安装，输入之前的保护密码就安装到iOS系统中了。<br />
同样，iOS系统中缺少第二级中级证书，从这里下载安装<a href="http://crt.comodoca.com/COMODOClientAuthenticationandSecureEmailCA.crt">http://crt.comodoca.com/COMODOClientAuthenticationandSecureEmailCA.crt</a>。</p>

<!--more-->

<h2 id="ios-1">iOS里启用加密和签名</h2>
<p>在iOS-邮件、通讯录、日历-邮件帐户-高级 启用S/MIME，选择上面安装的证书。iOS自带的mail程序发邮件即可自动进行加密和签名。</p>

<h2 id="section-2">群发公钥证书</h2>
<p>在电脑证书管理里导出证书（不包含私钥），windows是cer文件，把这个文件群发出来告诉朋友。别人给你发邮件就用这个证书进行加密。</p>

<h2 id="smime">我的S/MIME证书</h2>
<p>我的S/MIME证书<a href="http://xixitalk.github.io/static/pub.cer">http://xixitalk.github.io/static/pub.cer</a>,欢迎用S/MIME给我发邮件。你的系统也可能需要安装第二级COMODO的证书，从这里下载安装<a href="http://crt.comodoca.com/COMODOClientAuthenticationandSecureEmailCA.crt">http://crt.comodoca.com/COMODOClientAuthenticationandSecureEmailCA.crt</a>。</p>

<h2 id="section-3">其他参考</h2>
<p>Mac OSX导出证书到iOS参考<a href="http://feinstruktur.com/blog/2011/12/12/using-smime-on-ios-devices.html">http://feinstruktur.com/blog/2011/12/12/using-smime-on-ios-devices.html</a></p>
]]></content>
  </entry>
  
</feed>
