<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: linux | xixitalk's snippet]]></title>
  <link href="http://xixitalk.github.io/blog/categories/linux/atom.xml" rel="self"/>
  <link href="http://xixitalk.github.io/"/>
  <updated>2016-07-19T19:33:42+08:00</updated>
  <id>http://xixitalk.github.io/</id>
  <author>
    <name><![CDATA[xixitalk]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[linux内核编译预处理编译]]></title>
    <link href="http://xixitalk.github.io/blog/2016/07/19/preprocess-linux-kernel/"/>
    <updated>2016-07-19T21:39:01+08:00</updated>
    <id>http://xixitalk.github.io/blog/2016/07/19/preprocess-linux-kernel</id>
    <content type="html"><![CDATA[<p>linux 内核庞大而复杂。你有没有遇到内核代码阅读的时候因为宏定义或者inline层次太深而不知道到底代码是什么样子的。内核编译预处理将这个难题来解决。</p>

<!--more-->

<p>平台：linux 3.4.5 ARM，PC linux上类似，更简单些。</p>

<h4 id="v1">加V=1重新编译内核</h4>

<p><code>make</code>内核增加<code>V=1</code>选项，会详细打印编译过程，<code>-B</code>是要求重新编译内核所有模块。</p>

<p><code>
cd linux-3.4.5 &amp;&amp; make ARCH=arm defconfig &amp;&amp; make ARCH=arm CROSS_COMPILE=arm-buildroot-linux-uclibcgnueabi- EXTRAVERSION=- -B V=1 uImage
</code></p>

<p>编译内核并保存编译log到文件，搜索你要预编译的文件，如<code>mm/slab.c</code>，会找到如下编译命令：</p>

<p><code>
arm-buildroot-linux-uclibcgnueabi-gcc -Wp,-MD,mm/.slab.o.d  -nostdinc -isystem /home/test/build/gcc-4.9.8/build_arm/staging_dir/usr/bin/../lib/gcc/arm-buildroot-linux-uclibcgnueabi/4.9.8/include -I/home/test/linux/kernels/linux-3.4.5/arch/arm/include -Iarch/arm/include/generated -Iinclude  -include /home/test/linux/kernels/linux-3.4.5/include/linux/kconfig.h -D__KERNEL__ -mlittle-endian -Iarch/arm/mach-zx297510/include -Wall -Wundef -Wstrict-prototypes -Wno-trigraphs -fno-strict-aliasing -fno-common -Werror-implicit-function-declaration -Wno-format-security -fno-delete-null-pointer-checks -O2 -marm -fno-dwarf2-cfi-asm -mabi=aapcs-linux -mno-thumb-interwork -funwind-tables -D__LINUX_ARM_ARCH__=7 -march=armv7-a -msoft-float -Uarm -Wframe-larger-than=1024 -fno-stack-protector -Wno-unused-but-set-variable -fomit-frame-pointer -g -fno-inline-functions-called-once -Wdeclaration-after-statement -Wno-pointer-sign -fno-strict-overflow -fconserve-stack -DCC_HAVE_ASM_GOTO    -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(slab)"  -D"KBUILD_MODNAME=KBUILD_STR(slab)" -c -o mm/.tmp_slab.o mm/slab.c
</code></p>

<h4 id="section">编译预处理指定文件</h4>

<p>把编译命令修改成预处理命令：<code>-c -o mm/.tmp_slab.o</code>修改成<code>-E -o mm/slab.E mm/slab.c</code>，在内核目录<code>linux-3.4.5</code>直接执行。如果是交叉编译链，可能需要把<code>arm-buildroot-linux-uclibcgnueabi-gcc</code>所在路径加入到环境变量<code>PATH</code>里。</p>

<p><code>
arm-buildroot-linux-uclibcgnueabi-gcc -Wp,-MD,mm/.slab.o.d  -nostdinc -isystem /home/test/build/gcc-4.9.8/build_arm/staging_dir/usr/bin/../lib/gcc/arm-buildroot-linux-uclibcgnueabi/4.9.8/include -I/home/test/linux/kernels/linux-3.4.5/arch/arm/include -Iarch/arm/include/generated -Iinclude  -include /home/test/linux/kernels/linux-3.4.5/include/linux/kconfig.h -D__KERNEL__ -mlittle-endian -Iarch/arm/mach-zx297510/include -Wall -Wundef -Wstrict-prototypes -Wno-trigraphs -fno-strict-aliasing -fno-common -Werror-implicit-function-declaration -Wno-format-security -fno-delete-null-pointer-checks -O2 -marm -fno-dwarf2-cfi-asm -mabi=aapcs-linux -mno-thumb-interwork -funwind-tables -D__LINUX_ARM_ARCH__=7 -march=armv7-a -msoft-float -Uarm -Wframe-larger-than=1024 -fno-stack-protector -Wno-unused-but-set-variable -fomit-frame-pointer -g -fno-inline-functions-called-once -Wdeclaration-after-statement -Wno-pointer-sign -fno-strict-overflow -fconserve-stack -DCC_HAVE_ASM_GOTO    -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(slab)"  -D"KBUILD_MODNAME=KBUILD_STR(slab)" -E -o mm/slab.E mm/slab.c
</code></p>

<p>执行完命令，在内核的<code>mm</code>目录就能看到<code>slab.c</code>的预处理后文件<code>slab.E</code>文件了。看一下<code>kmalloc</code>函数代码，是不是清晰很多了。</p>

<p><code>slab_def.h</code>里的原始<code>kmalloc</code></p>

<p>```
static __always_inline void *kmalloc(size_t size, gfp_t flags)
{
	struct kmem_cache *cachep;
	void *ret;</p>

<pre><code>if (__builtin_constant_p(size)) {
	int i = 0;

	if (!size)
		return ZERO_SIZE_PTR;
</code></pre>

<h1 id="define-cachex-">define CACHE(x) \</h1>
<pre><code>	if (size &lt;= x) \
		goto found; \
	else \
		i++; #include &lt;linux/kmalloc_sizes.h&gt; #undef CACHE
	return NULL; found: #ifdef CONFIG_ZONE_DMA
	if (flags &amp; GFP_DMA)
		cachep = malloc_sizes[i].cs_dmacachep;
	else #endif
		cachep = malloc_sizes[i].cs_cachep;

	ret = kmem_cache_alloc_trace(size, cachep, flags);

	return ret;
}
return __kmalloc(size, flags); } ```
</code></pre>

<p>预处理后的<code>kmalloc</code>,流程是不是清晰多了。</p>

<p>```
static inline <strong>attribute</strong>((always_inline)) <strong>attribute</strong>((always_inline)) void *kmalloc(size_t size, gfp_t flags)
{
 struct kmem_cache *cachep;
 void *ret;</p>

<p>if (__builtin_constant_p(size)) {
  int i = 0;</p>

<p>if (!size)
   return ((void *)16);</p>

<h1 id="includelinuxkmallocsizesh-1">1 “include/linux/kmalloc_sizes.h” 1</h1>

<p>if (size &lt;= 32) goto found; else i++;
 if (size &lt;= 64) goto found; else i++;
 if (size &lt;= 128) goto found; else i++;
 if (size &lt;= 192) goto found; else i++;
 if (size &lt;= 256) goto found; else i++;
 if (size &lt;= 512) goto found; else i++;
 if (size &lt;= 1024) goto found; else i++;
 if (size &lt;= 2048) goto found; else i++;
 if (size &lt;= 4096) goto found; else i++;
 if (size &lt;= 8192) goto found; else i++;
 if (size &lt;= 16384) goto found; else i++;
 if (size &lt;= 32768) goto found; else i++;
 if (size &lt;= 65536) goto found; else i++;
 if (size &lt;= 131072) goto found; else i++;
 if (size &lt;= 262144) goto found; else i++;
 if (size &lt;= 524288) goto found; else i++;
 if (size &lt;= 1048576) goto found; else i++;
 if (size &lt;= 2097152) goto found; else i++;
 if (size &lt;= 4194304) goto found; else i++;
# 145 “include/linux/slab_def.h” 2</p>

<p>return ((void *)0);
found:
   cachep = malloc_sizes[i].cs_cachep;</p>

<p>ret = kmem_cache_alloc_trace(size, cachep, flags);</p>

<p>return ret;
 }
 return __kmalloc(size, flags);
}
```</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[linux栈和内存管理]]></title>
    <link href="http://xixitalk.github.io/blog/2016/07/18/linux-stack-and-memory-management/"/>
    <updated>2016-07-18T17:11:52+08:00</updated>
    <id>http://xixitalk.github.io/blog/2016/07/18/linux-stack-and-memory-management</id>
    <content type="html"><![CDATA[<p>先记录，待细看</p>

<!--more-->

<p><a href="http://blog.csdn.net/daniel_ice/article/details/8146003">http://blog.csdn.net/daniel_ice/article/details/8146003</a></p>

<p><a href="http://gityuan.com/2015/10/30/kernel-memory/">http://gityuan.com/2015/10/30/kernel-memory/</a></p>

<p><a href="http://www.2ndmoon.net/weblog/?p=509">http://www.2ndmoon.net/weblog/?p=509</a></p>

<p><a href="http://www.cnblogs.com/tolimit/p/4610974.html">http://www.cnblogs.com/tolimit/p/4610974.html</a></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[pthread退出时自动回收资源]]></title>
    <link href="http://xixitalk.github.io/blog/2016/07/18/pthread-autoclean-when-exiting/"/>
    <updated>2016-07-18T16:49:16+08:00</updated>
    <id>http://xixitalk.github.io/blog/2016/07/18/pthread-autoclean-when-exiting</id>
    <content type="html"><![CDATA[<p>pthread线程创建后默认属性是joinable，线程函数执行完资源不会自动回收线程资源，需要主进程<code>pthread_join</code>进行回收，否则就会造成不必要的内存占用，频繁创建退出线程可能会造成系统内存耗尽。除了<code>pthread_join</code>用这种办法更好些。</p>

<!--more-->

<p>线程函数加上<code>pthread_detach(pthread_self())</code>的话，线程状态改变成<code>unjoinable</code>，这样线程函数尾部直接 pthread_exit线程就会自动退出。</p>

<p>```
static void  thread_fn( void *args)
{
	pthread_detach(pthread_self());</p>

<pre><code>while(flag)
{
	/*do something*/
}

pthread_exit(NULL); } ```
</code></pre>

<h2 id="section">参考文章</h2>

<p><a href="http://blog.csdn.net/trinea/article/details/5191165">http://blog.csdn.net/trinea/article/details/5191165</a></p>

<p><a href="http://www.lxway.net/499814656.html">http://www.lxway.net/499814656.html</a></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[linux内核kmalloc和vmalloc的区别]]></title>
    <link href="http://xixitalk.github.io/blog/2016/07/18/kmalloc-vs-vmalloc/"/>
    <updated>2016-07-18T16:41:56+08:00</updated>
    <id>http://xixitalk.github.io/blog/2016/07/18/kmalloc-vs-vmalloc</id>
    <content type="html"><![CDATA[<p>kmalloc 和 vmalloc的区别</p>

<!--more-->

<h4 id="kmalloc">kmalloc</h4>

<p><code>
void *kmalloc(size_t size, gfp_t flags)
</code></p>

<p>kmalloc是内核中最常用的一种内存分配方式，<strong>连续的物理内存</strong>。如果size是常量，调用<code>kmem_cache_alloc_trace</code>分配，否则调用<code>__kmalloc</code>分配。size如果是常量且大于4M，直接返回0（内核版本3.4.5）；如果size是0，返回地址是<code>((void *)16)</code>。</p>

<h4 id="vmalloc">vmalloc</h4>

<p><code>
void *vmalloc(unsigned long size)
</code></p>

<p>kmalloc内存分配方式都是物理连续的，能保证较低的平均访问时间。但是在某些场合中，对内存区的请求不是很频繁，较高的内存访问时间也 可以接受，这是就可以分配一段<strong>线性连续，物理不连续</strong>的地址，带来的好处是一次可以分配较大块的内存。vmalloc对 一次能分配的内存大小没有明确限制。</p>

<h5 id="kmalloc-1">kmalloc预处理后的代码</h5>

<p>```
static inline <strong>attribute</strong>((always_inline)) <strong>attribute</strong>((always_inline)) void *kmalloc(size_t size, gfp_t flags)
{
 struct kmem_cache *cachep;
 void *ret;</p>

<p>if (__builtin_constant_p(size)) {
  int i = 0;</p>

<p>if (!size)
   return ((void *)16);</p>

<h1 id="includelinuxkmallocsizesh-1">1 “include/linux/kmalloc_sizes.h” 1</h1>
<p>if (size &lt;= 32) goto found; else i++;
 if (size &lt;= 64) goto found; else i++;
 if (size &lt;= 128) goto found; else i++;
 if (size &lt;= 192) goto found; else i++;
 if (size &lt;= 256) goto found; else i++;
 if (size &lt;= 512) goto found; else i++;
 if (size &lt;= 1024) goto found; else i++;
 if (size &lt;= 2048) goto found; else i++;
 if (size &lt;= 4096) goto found; else i++;
 if (size &lt;= 8192) goto found; else i++;
 if (size &lt;= 16384) goto found; else i++;
 if (size &lt;= 32768) goto found; else i++;
 if (size &lt;= 65536) goto found; else i++;
 if (size &lt;= 131072) goto found; else i++;
 if (size &lt;= 262144) goto found; else i++;
 if (size &lt;= 524288) goto found; else i++;
 if (size &lt;= 1048576) goto found; else i++;
 if (size &lt;= 2097152) goto found; else i++;
 if (size &lt;= 4194304) goto found; else i++;
# 145 “include/linux/slab_def.h” 2</p>

<p>return ((void *)0);
found:
   cachep = malloc_sizes[i].cs_cachep;</p>

<p>ret = kmem_cache_alloc_trace(size, cachep, flags);</p>

<p>return ret;
 }
 return __kmalloc(size, flags);
}</p>

<p>void *__kmalloc(size_t size, gfp_t flags)
{
 return __do_kmalloc(size, flags, ((void *)0));
}</p>

<p>static inline <strong>attribute</strong>((always_inline)) <strong>attribute</strong>((always_inline)) void *__do_kmalloc(size_t size, gfp_t flags, void *caller)
{
 struct kmem_cache *cachep;
 void *ret;</p>

<p>cachep = __find_general_cachep(size, flags);
 if (__builtin_expect(!!(((unsigned long)(cachep) &lt;= (unsigned long)((void *)16))), 0))
  return cachep;
 ret = __cache_alloc(cachep, flags, caller);</p>

<p>trace_kmalloc((unsigned long) caller, ret,
        size, cachep-&gt;buffer_size, flags);</p>

<p>return ret;
}
```</p>

<h1 id="section">引用文章</h1>

<p><a href="http://www.ahlinux.com/start/kernel/18604.html">http://www.ahlinux.com/start/kernel/18604.html</a></p>

<p><a href="http://blog.csdn.net/bullbat/article/details/7181396">http://blog.csdn.net/bullbat/article/details/7181396</a></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[linux kernel全局变量contig_page_data含义]]></title>
    <link href="http://xixitalk.github.io/blog/2016/07/13/kernel-contig_page_data/"/>
    <updated>2016-07-13T17:03:20+08:00</updated>
    <id>http://xixitalk.github.io/blog/2016/07/13/kernel-contig_page_data</id>
    <content type="html"><![CDATA[<p><code>contig_page_data</code>是内核内存管理一个很重要的变量。</p>

<!--more-->

<p>平台：uClinux 内核版本号：linux-3.4.12</p>

<p><img src="http://7bv9id.com1.z0.glb.clouddn.com/contig_page_data.png" alt="enter image description here" /></p>

<p><code>watermark</code>是3840 4800 5760对应 watermark[min] watermark[low] watermark[high]，这里是page数，一个page 4K，所以<code>watermark</code>对应<code>min_free_kbytes</code>是3840*4K是15360（15M），符合配置<code>echo 15360 &gt; /proc/sys/vm/min_free_kbytes</code>。其他计算如下。</p>

<p><code>
 watermark[min] = min_free_kbytes换算为page单位即可
 watermark[low] = watermark[min] * 5 / 4
 watermark[high] = watermark[min] * 3 / 2
</code></p>

<p>在系统空闲内存低于 watermark[low]时，开始启动内核线程kswapd进行内存回收，直到该zone的空闲内存数量达到watermark[high]后停止回收。如果上层申请内存的速度太快，导致空闲内存降至watermark[min]后，内核就会进行direct reclaim（直接回收），即直接在应用程序的进程上下文中进行回收，再用回收上来的空闲页满足内存申请，因此实际会阻塞应用程序，带来一定的响应延迟，而且可能会触发系统OOM。这是因为watermark[min]以下的内存属于系统的自留内存，用以满足特殊使用，所以不会给用户态的普通申请来用。</p>

<p>free_area里order是0到10，对应4K到4M。free_list[n]是双向链表，只有next的next指向同样的节点才是表示链表为空。（双向链表，很明显如果只有两个节点，next和prev都是另一个节点）。和<code>cat /proc/pagetypeinfo</code>信息一致。</p>

<p><code>contig_page_data</code>里的<code>vm_stat</code>对应mmzone.h里<code>zone_stat_item</code>枚举。另外本身有一个内核全局变量<code>vm_stat</code>，值和<code>contig_page_data</code>的这个<code>vm_stat</code>一样的。这个参数可以对照着<code>/proc/meminfo</code>一起看。</p>

<p>page_alloc.c  show_free_areas()</p>

<p><code>
for (type = 0; type &lt; MIGRATE_TYPES; type++) {
				if (!list_empty(&amp;area-&gt;free_list[type]))
					types[order] |= 1 &lt;&lt; type;
			}
</code></p>

<p>mmzone.h里看出MIGRATE_TYPES为4。<strong>0是UNMOVABLE区，1是RECLAIMABLE可回收区，2是可MOVABLE区，3是PCPTYPES或者RESERVE保留区</strong>。</p>

<p><code>
enum {
	MIGRATE_UNMOVABLE,
	MIGRATE_RECLAIMABLE,
	MIGRATE_MOVABLE,
	MIGRATE_PCPTYPES,	/* the number of types on the pcp lists */
	MIGRATE_RESERVE = MIGRATE_PCPTYPES,
#ifdef CONFIG_CMA
	/*
	 * MIGRATE_CMA migration type is designed to mimic the way
	 * ZONE_MOVABLE works.  Only movable pages can be allocated
	 * from MIGRATE_CMA pageblocks and page allocator never
	 * implicitly change migration type of MIGRATE_CMA pageblock.
	 *
	 * The way to use it is to change migratetype of a range of
	 * pageblocks to MIGRATE_CMA which can be done by
	 * __free_pageblock_cma() function.  What is important though
	 * is that a range of pageblocks must be aligned to
	 * MAX_ORDER_NR_PAGES should biggest page be bigger then
	 * a single pageblock.
	 */
	MIGRATE_CMA,
#endif
#ifdef CONFIG_MEMORY_ISOLATION
	MIGRATE_ISOLATE,	/* can't allocate from here */
#endif
	MIGRATE_TYPES
};
</code></p>

<p><code>
enum zone_stat_item {
	/* First 128 byte cacheline (assuming 64 bit words) */
	NR_FREE_PAGES,
	NR_ALLOC_BATCH,
	NR_LRU_BASE,
	NR_INACTIVE_ANON = NR_LRU_BASE, /* must match order of LRU_[IN]ACTIVE */
	NR_ACTIVE_ANON,		/*  "     "     "   "       "         */
	NR_INACTIVE_FILE,	/*  "     "     "   "       "         */
	NR_ACTIVE_FILE,		/*  "     "     "   "       "         */
	NR_UNEVICTABLE,		/*  "     "     "   "       "         */
	NR_MLOCK,		/* mlock()ed pages found and moved off LRU */
	NR_ANON_PAGES,	/* Mapped anonymous pages */
	NR_FILE_MAPPED,	/* pagecache pages mapped into pagetables.
			   only modified from process context */
	NR_FILE_PAGES,
	NR_FILE_DIRTY,
	NR_WRITEBACK,
	NR_SLAB_RECLAIMABLE,
	NR_SLAB_UNRECLAIMABLE,
	NR_PAGETABLE,		/* used for pagetables */
	NR_KERNEL_STACK,
	/* Second 128 byte cacheline */
	NR_UNSTABLE_NFS,	/* NFS unstable pages */
	NR_BOUNCE,
	NR_VMSCAN_WRITE,
	NR_VMSCAN_IMMEDIATE,	/* Prioritise for reclaim when writeback ends */
	NR_WRITEBACK_TEMP,	/* Writeback using temporary buffers */
	NR_ISOLATED_ANON,	/* Temporary isolated pages from anon lru */
	NR_ISOLATED_FILE,	/* Temporary isolated pages from file lru */
	NR_SHMEM,		/* shmem pages (included tmpfs/GEM pages) */
	NR_DIRTIED,		/* page dirtyings since bootup */
	NR_WRITTEN,		/* page writings since bootup */
#ifdef CONFIG_NUMA
	NUMA_HIT,		/* allocated in intended node */
	NUMA_MISS,		/* allocated in non intended node */
	NUMA_FOREIGN,		/* was intended here, hit elsewhere */
	NUMA_INTERLEAVE_HIT,	/* interleaver preferred this zone */
	NUMA_LOCAL,		/* allocation from local node */
	NUMA_OTHER,		/* allocation from other node */
#endif
	NR_ANON_TRANSPARENT_HUGEPAGES,
	NR_FREE_CMA_PAGES,
	NR_VM_ZONE_STAT_ITEMS };
</code></p>

<h4 id="section">参考文章</h4>

<p><a href="http://kernel.taobao.org/index.php?title=Kernel_Documents/mm_sysctl">http://kernel.taobao.org/index.php?title=Kernel_Documents/mm_sysctl</a></p>
]]></content>
  </entry>
  
</feed>
