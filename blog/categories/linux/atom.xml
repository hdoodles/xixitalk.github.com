<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: linux | xixitalk's snippet]]></title>
  <link href="http://xixitalk.github.io/blog/categories/linux/atom.xml" rel="self"/>
  <link href="http://xixitalk.github.io/"/>
  <updated>2016-08-18T11:41:21+08:00</updated>
  <id>http://xixitalk.github.io/</id>
  <author>
    <name><![CDATA[xixitalk]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[netlink遇到ENOBUFS错误]]></title>
    <link href="http://xixitalk.github.io/blog/2016/08/18/netlink-ENOBUFS/"/>
    <updated>2016-08-18T16:49:42+08:00</updated>
    <id>http://xixitalk.github.io/blog/2016/08/18/netlink-ENOBUFS</id>
    <content type="html"><![CDATA[<p>一个场景：USB插拔的时候内核会通过netlink广播到user层，多个应用接收这个消息。但是出现了errno 105错误，105错误是：<code>No buffer space available</code></p>

<!--more-->

<p>经过内核代码分析，<code>af_netlink.c</code>里<code>netlink_broadcast_deliver</code>函数返回-1才会触发<code>ENOBUFS</code>流程。加<code>printk</code>和<code>panic</code>复现问题(因为嵌入式开发环境抓panic死机现场分析和串口log都太方便了)。</p>

<p>```
static int netlink_broadcast_deliver(struct sock *sk, struct sk_buff *skb)
{
	struct netlink_sock *nlk = nlk_sk(sk);</p>

<pre><code>if (atomic_read(&amp;sk-&gt;sk_rmem_alloc) &lt;= sk-&gt;sk_rcvbuf &amp;&amp;
    !test_bit(0, &amp;nlk-&gt;state)) {
	skb_set_owner_r(skb, sk);
	__netlink_sendskb(sk, skb);
	return atomic_read(&amp;sk-&gt;sk_rmem_alloc) &gt; (sk-&gt;sk_rcvbuf &gt;&gt; 1);
}
printk("[testcode]netlink sk_rmem_alloc:%x sk_rcvbuf:%x \n",atomic_read(&amp;sk-&gt;sk_rmem_alloc),sk-&gt;sk_rcvbuf);
panic("[testcode]netlink broadcast panic\n");
return -1; } ```
</code></pre>

<p>抓取的串口log如下显示<code>sk_rcvbuf</code>确实小于<code>sk_rmem_alloc</code>了，没有空间了。</p>

<blockquote>
  <p>[   18.618473] [testcode]netlink sk_rmem_alloc:b00 sk_rcvbuf:8b8  [<br />
18.623727] Kernel panic - not syncing: [testcode]netlink broadcast panic</p>
</blockquote>

<p>对比发现死机现场里的<code>kobject_uevent_env</code>函数里的<code>uevent_sock</code>变量里<code>sk_sndbuf</code>和<code>sk_rcvbuf</code>都是163840（160K）。而<code>netlink_broadcast_deliver</code>里sock是8b8（2232）。很明显netlink接收socket里的sock比内核驱动的sock接收buf差距太大了。</p>

<p>内核sock.c里<code>sock_init_data</code>函数里进行sock初始化，<code>sk_rcvbuf</code>和<code>sk_sndbuf</code>初始化成<code>sysctl_rmem_default</code>。<code>sysctl_rmem_default</code>是个全局变量，导出的panic现场看值就是163840。</p>

<blockquote>
  <p>sk-&gt;sk_rcvbuf		=	sysctl_rmem_default;
sk-&gt;sk_sndbuf		=	sysctl_wmem_default;</p>
</blockquote>

<p>看应用netlink的接收，果然用<code>setsockopt</code>修改了<code>RCVBUF</code>。</p>

<p>```
    const int buffersize = 1024;<br />
    int ret;  </p>

<pre><code>struct sockaddr_nl snl;  
bzero(&amp;snl, sizeof(struct sockaddr_nl));  
snl.nl_family = AF_NETLINK;  
snl.nl_pid = getpid();  
snl.nl_groups = 1;  

int s = socket(PF_NETLINK, SOCK_DGRAM, NETLINK_KOBJECT_UEVENT);  
if (s == -1)   
{  
    perror("socket");  
    return -1;  
}  
setsockopt(s, SOL_SOCKET, SO_RCVBUF, &amp;buffersize, sizeof(buffersize));   ```
</code></pre>

<p>C库的<code>setsockopt</code>函数会通过系统调用进入到内核<code>sock.c</code>文件里的<code>sock_setsockopt</code>函数。<code>SOCK_MIN_RCVBUF</code>就是2232。很明显应用<code>setsockopt</code>的<code>buffersize</code>是1024，乘以2还小于<code>SOCK_MIN_RCVBUF</code>，所以<code>sk_rcvbuf</code>就变成<code>SOCK_MIN_RCVBUF</code>。</p>

<p><code>
	case SO_RCVBUF:
	    if (val &gt; sysctl_rmem_max)
			val = sysctl_rmem_max;
		if ((val * 2) &lt; SOCK_MIN_RCVBUF)
			sk-&gt;sk_rcvbuf = SOCK_MIN_RCVBUF;
		else
			sk-&gt;sk_rcvbuf = val * 2;
		break;
</code></p>

<p>解决办法：删除应用代码里的<code>setsockopt</code>语句,这样<code>sk_rcvbuf</code>默认就是160K，或者用<code>setsockopt</code>设置合适的大小。</p>

<p>通过Google发现，网络上好多netlink实例都用了<code>setsockopt</code>设置了1024的buffer大小。应用这个代码应该是从网上抄来的。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[在内核里获取当前任务名]]></title>
    <link href="http://xixitalk.github.io/blog/2016/08/10/current-comm/"/>
    <updated>2016-08-10T16:33:02+08:00</updated>
    <id>http://xixitalk.github.io/blog/2016/08/10/current-comm</id>
    <content type="html"><![CDATA[<p>遇到一个问题，在一个内核模块里使用current-&gt;comm保存当前任务名，编译报错:<code>dereferencing pointer to incomplete type</code>。</p>

<!--more-->

<p>经过搜索发现，除了要包含<code>current.h</code>外，还要包含<code>sched.h</code>。原因是<code>struct task_struct</code>在<code>sched.h</code>里定义。<code>comm</code>是数组字符串，长度是<code>TASK_COMM_LEN</code>，一般是16个字节，记得保证足够的空间，防止内存越界。</p>

<p>用法实例如下：</p>

<p>```
#include &lt;linux/sched.h&gt;
#include &lt;asm/current.h&gt;</p>

<p>static char g_cfg_app_name[TASK_COMM_LEN*2] = { 0 };</p>

<p>strncpy(g_cfg_app_name,current-&gt;comm,TASK_COMM_LEN);
```</p>

<h4 id="section">参考文章</h4>

<p><a href="http://www.xuebuyuan.com/1814455.html">http://www.xuebuyuan.com/1814455.html</a></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[jemalloc add2line ligsigsegv]]></title>
    <link href="http://xixitalk.github.io/blog/2016/08/04/jemalloc-add2line-ligsigsegv/"/>
    <updated>2016-08-04T02:38:22+08:00</updated>
    <id>http://xixitalk.github.io/blog/2016/08/04/jemalloc-add2line-ligsigsegv</id>
    <content type="html"><![CDATA[<p>一些定位工具还需要研究</p>

<!--more-->

<p><a href="http://www.cnblogs.com/djinmusic/archive/2013/02/04/2891753.html">http://www.cnblogs.com/djinmusic/archive/2013/02/04/2891753.html</a></p>

<p><a href="http://blog.codingnow.com/2014/01/out_of_range_bug.html">http://blog.codingnow.com/2014/01/out_of_range_bug.html</a></p>

<p><a href="http://blog.csdn.net/olidrop/article/details/7295908">http://blog.csdn.net/olidrop/article/details/7295908</a></p>

<p><a href="https://www.gnu.org/software/libsigsegv/">https://www.gnu.org/software/libsigsegv/</a></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[linux内核代码瘦身]]></title>
    <link href="http://xixitalk.github.io/blog/2016/07/21/linux-kernel-source-strip/"/>
    <updated>2016-07-21T05:07:23+08:00</updated>
    <id>http://xixitalk.github.io/blog/2016/07/21/linux-kernel-source-strip</id>
    <content type="html"><![CDATA[<p>linux内核代码瘦身，原理：把不参与编译的代码删除，这样用Source Insight工具阅读代码的时候就轻简了很多。</p>

<p>例子数据：原本一个嵌入式linux内核代码1万7千个C文件，精简之后只有1222个C文件，删除了1万6千个C文件。</p>

<!--more-->

<h4 id="section">第一步 清理临时文件</h4>

<p>内核编译clean，把内核编译的临时文件都清除。</p>

<h4 id="c">第二步 保存所有C文件路径</h4>

<p><code>
cd linux-3.4.5
find ./ -name "*.c" | tee allsrc.txt
</code></p>

<h4 id="section-1">第三步 编译内核</h4>

<p>无需多讲，编译内核。</p>

<h4 id="strippy">第四步 用strip.py清除不参与编译的代码</h4>

<p>部分代码使用了include C代码，所以用<code>ignorefilelist</code>自定义文件过滤。<code>scripts</code>是工具目录，<code>./drivers/usb/gadget/</code>里inlucde C代码太多了，所以这两个目录直接目录过滤，添加到<code>ignorepathlist</code>自定义目录过滤里。</p>

<p>```
import sys
import os</p>

<p>ignorefilelist=[‘fsr-2level.c’,’fsr-3level.c’,’percpu-km.c’,’percpu-vm.c’,’nf_conntrack_h323_types.c’]
ignorepathlist=[’./scripts/’,’./drivers/usb/gadget/’]</p>

<p>f = open(‘allsrc.txt’,’r’)  </p>

<p>for line in f.readlines():
	cfilename=line.strip(‘\n’)
	objfilename=cfilename.replace(“.c”,”.o”)
	asmfilename=cfilename.replace(“.c”,”.s”)
	exefilename=cfilename.replace(“.c”,””)</p>

<pre><code>cfile=cfilename.split('/')[-1]
#print cfile

flag=False
for item in ignorepathlist:
	if cfilename.find(item)!=-1:
		#print cfilename
		flag=True
		break
if flag:
	continue

if cfile in ignorefilelist:
	#print cfile,cfilename
	continue

if  os.path.exists(objfilename):
	continue
if os.path.exists(asmfilename):
	#print asmfilename
	continue
if os.path.exists(exefilename):
	#print exefilename
	continue

if os.path.exists(cfilename):
	print objfilename,"NOT USING and rm ",cfilename
	os.remove(cfilename)
	pass
</code></pre>

<p>f.close()
```</p>

<p>保存代码为<code>strip.py</code>，保存在内核目录。</p>

<p><code>
cd linux-3.4.5
python strip.py
</code></p>

<h3 id="section-2">第五步 重新编译内核</h3>

<p>重新编译内核。</p>

<p>如果编译成功，清理临时文件后保存代码用于阅读；<br />
如果编译失败，恢复缺失的文件，修改strip.py，接着编译，直到内核重新编译通过，清理临时文件后保存代码用于阅读。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[linux内核代码预处理后便于阅读]]></title>
    <link href="http://xixitalk.github.io/blog/2016/07/19/preprocess-linux-kernel/"/>
    <updated>2016-07-19T21:39:01+08:00</updated>
    <id>http://xixitalk.github.io/blog/2016/07/19/preprocess-linux-kernel</id>
    <content type="html"><![CDATA[<p>linux 内核庞大而复杂。内核代码阅读的时候，有没有遇到因为宏定义或者inline层次太深而不知道到底代码是什么样子。代码预处理可以解决这个难题。</p>

<!--more-->

<p>平台：linux 3.4.5 ARM，PC linux上类似，更简单些。</p>

<h4 id="v1">加V=1重新编译内核</h4>

<p><code>make</code>内核增加<code>V=1</code>选项，会详细打印编译过程，<code>-B</code>是要求重新编译内核所有模块。</p>

<p><code>
cd linux-3.4.5 &amp;&amp; make ARCH=arm defconfig &amp;&amp; make ARCH=arm CROSS_COMPILE=arm-buildroot-linux-uclibcgnueabi- EXTRAVERSION=- -B V=1 uImage
</code></p>

<p>编译内核并保存编译log到文件，搜索你要预编译的文件，如<code>mm/slab.c</code>，会找到如下编译命令：</p>

<p><code>
arm-buildroot-linux-uclibcgnueabi-gcc -Wp,-MD,mm/.slab.o.d  -nostdinc -isystem /home/test/build/gcc-4.9.8/build_arm/staging_dir/usr/bin/../lib/gcc/arm-buildroot-linux-uclibcgnueabi/4.9.8/include -I/home/test/linux/kernels/linux-3.4.5/arch/arm/include -Iarch/arm/include/generated -Iinclude  -include /home/test/linux/kernels/linux-3.4.5/include/linux/kconfig.h -D__KERNEL__ -mlittle-endian -Iarch/arm/mach-zx297510/include -Wall -Wundef -Wstrict-prototypes -Wno-trigraphs -fno-strict-aliasing -fno-common -Werror-implicit-function-declaration -Wno-format-security -fno-delete-null-pointer-checks -O2 -marm -fno-dwarf2-cfi-asm -mabi=aapcs-linux -mno-thumb-interwork -funwind-tables -D__LINUX_ARM_ARCH__=7 -march=armv7-a -msoft-float -Uarm -Wframe-larger-than=1024 -fno-stack-protector -Wno-unused-but-set-variable -fomit-frame-pointer -g -fno-inline-functions-called-once -Wdeclaration-after-statement -Wno-pointer-sign -fno-strict-overflow -fconserve-stack -DCC_HAVE_ASM_GOTO    -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(slab)"  -D"KBUILD_MODNAME=KBUILD_STR(slab)" -c -o mm/.tmp_slab.o mm/slab.c
</code></p>

<h4 id="section">编译预处理指定文件</h4>

<p>把编译命令修改成预处理命令：<code>-c -o mm/.tmp_slab.o</code>修改成<code>-E -o mm/slab.E mm/slab.c</code>，在内核目录<code>linux-3.4.5</code>直接执行。如果是交叉编译链，可能需要把<code>arm-buildroot-linux-uclibcgnueabi-gcc</code>所在路径加入到环境变量<code>PATH</code>里。</p>

<p><code>
arm-buildroot-linux-uclibcgnueabi-gcc -Wp,-MD,mm/.slab.o.d  -nostdinc -isystem /home/test/build/gcc-4.9.8/build_arm/staging_dir/usr/bin/../lib/gcc/arm-buildroot-linux-uclibcgnueabi/4.9.8/include -I/home/test/linux/kernels/linux-3.4.5/arch/arm/include -Iarch/arm/include/generated -Iinclude  -include /home/test/linux/kernels/linux-3.4.5/include/linux/kconfig.h -D__KERNEL__ -mlittle-endian -Iarch/arm/mach-zx297510/include -Wall -Wundef -Wstrict-prototypes -Wno-trigraphs -fno-strict-aliasing -fno-common -Werror-implicit-function-declaration -Wno-format-security -fno-delete-null-pointer-checks -O2 -marm -fno-dwarf2-cfi-asm -mabi=aapcs-linux -mno-thumb-interwork -funwind-tables -D__LINUX_ARM_ARCH__=7 -march=armv7-a -msoft-float -Uarm -Wframe-larger-than=1024 -fno-stack-protector -Wno-unused-but-set-variable -fomit-frame-pointer -g -fno-inline-functions-called-once -Wdeclaration-after-statement -Wno-pointer-sign -fno-strict-overflow -fconserve-stack -DCC_HAVE_ASM_GOTO    -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(slab)"  -D"KBUILD_MODNAME=KBUILD_STR(slab)" -E -o mm/slab.E mm/slab.c
</code></p>

<p>执行完命令，在内核的<code>mm</code>目录就能看到<code>slab.c</code>的预处理后文件<code>slab.E</code>文件了。看一下<code>kmalloc</code>函数代码，是不是清晰很多了。</p>

<p><code>slab_def.h</code>里的原始<code>kmalloc</code></p>

<p>```
static __always_inline void *kmalloc(size_t size, gfp_t flags)
{
	struct kmem_cache *cachep;
	void *ret;</p>

<pre><code>if (__builtin_constant_p(size)) {
	int i = 0;

	if (!size)
		return ZERO_SIZE_PTR;
</code></pre>

<h1 id="define-cachex-">define CACHE(x) \</h1>
<pre><code>	if (size &lt;= x) \
		goto found; \
	else \
		i++; #include &lt;linux/kmalloc_sizes.h&gt; #undef CACHE
	return NULL; found: #ifdef CONFIG_ZONE_DMA
	if (flags &amp; GFP_DMA)
		cachep = malloc_sizes[i].cs_dmacachep;
	else #endif
		cachep = malloc_sizes[i].cs_cachep;

	ret = kmem_cache_alloc_trace(size, cachep, flags);

	return ret;
}
return __kmalloc(size, flags); } ```
</code></pre>

<p>预处理后的<code>kmalloc</code>,流程是不是清晰多了。</p>

<p>```
static inline <strong>attribute</strong>((always_inline)) <strong>attribute</strong>((always_inline)) void *kmalloc(size_t size, gfp_t flags)
{
 struct kmem_cache *cachep;
 void *ret;</p>

<p>if (__builtin_constant_p(size)) {
  int i = 0;</p>

<p>if (!size)
   return ((void *)16);</p>

<h1 id="includelinuxkmallocsizesh-1">1 “include/linux/kmalloc_sizes.h” 1</h1>

<p>if (size &lt;= 32) goto found; else i++;
 if (size &lt;= 64) goto found; else i++;
 if (size &lt;= 128) goto found; else i++;
 if (size &lt;= 192) goto found; else i++;
 if (size &lt;= 256) goto found; else i++;
 if (size &lt;= 512) goto found; else i++;
 if (size &lt;= 1024) goto found; else i++;
 if (size &lt;= 2048) goto found; else i++;
 if (size &lt;= 4096) goto found; else i++;
 if (size &lt;= 8192) goto found; else i++;
 if (size &lt;= 16384) goto found; else i++;
 if (size &lt;= 32768) goto found; else i++;
 if (size &lt;= 65536) goto found; else i++;
 if (size &lt;= 131072) goto found; else i++;
 if (size &lt;= 262144) goto found; else i++;
 if (size &lt;= 524288) goto found; else i++;
 if (size &lt;= 1048576) goto found; else i++;
 if (size &lt;= 2097152) goto found; else i++;
 if (size &lt;= 4194304) goto found; else i++;
# 145 “include/linux/slab_def.h” 2</p>

<p>return ((void *)0);
found:
   cachep = malloc_sizes[i].cs_cachep;</p>

<p>ret = kmem_cache_alloc_trace(size, cachep, flags);</p>

<p>return ret;
 }
 return __kmalloc(size, flags);
}
```</p>

]]></content>
  </entry>
  
</feed>
